nm_blocks
temp <- total_nm_tracts %>%
st_point_on_surface() %>%
st_make_valid() %>%
st_join(temp_util %>% select(NAME)) %>%
st_drop_geometry() %>%
group_by(Name = NAME) %>%
filter(!is.na(Name)) %>%
summarize(`Pop under 80 AMI` = sum(AMI_80),
`Medicaid` = sum(medicaid_pop),
`SNAP` = sum(snap_hh),
`Total Population` = sum(total_pop)) %>%
arrange(desc(`Pop under 80 AMI`))
datatable(temp, caption = "New Mexico, Sources: ACS 2019 and HUD CHAS")%>%
formatCurrency('Pop under 80 AMI',currency = "", interval = 3, mark = ",") %>%
formatCurrency('Medicaid',currency = "", interval = 3, mark = ",") %>%
formatCurrency('SNAP',currency = "", interval = 3, mark = ",") %>%
formatCurrency('Total Population',currency = "", interval = 3, mark = ",")
nm_df <- add_geo %>%
filter(State_Name == "New Mexico")
pal <- colorNumeric(
palette = "Reds",
# reverse=TRUE,
domain = nm_df$AMI_80)
pal2 <- colorNumeric(
palette = "Purples",
# reverse=TRUE,
domain = nm_df$AMI_80_Pct)
pal3 <- colorNumeric(
palette = "Greens",
# reverse=TRUE,
domain = nm_blocks$snap_hh)
pal4 <- colorNumeric(
palette = "Blues",
# reverse=TRUE,
domain = nm_blocks$medicaid_pop)
map <- leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(data=temp_util,
group="Utility Zones",
stroke=TRUE,
color="black",
dashArray="3",
fillOpacity=0,
popup=paste("Utility Zone: ", temp_util$new_name)
) %>%
addPolygons(
data = nm_df,
group="80% AMI",  # This should be consistent with the group name in the addLegend function
stroke=FALSE,
smoothFactor=0.2,
fillOpacity=0.7,
color=~pal(AMI_80),
popup=paste("Tract: ", nm_df$geoid, "<br>",
"HHs at 80% AMI: ", nm_df$AMI_80)
) %>%
addLegend("bottomleft",
group="80% AMI",  # This should be consistent with the group name in the addPolygons function
pal = pal,
values = nm_df$AMI_80,
title="Number of HHs at 80% AMI"
) %>%
# addPolygons(
#   data=nm_df,
#   group="80% AMI Percent",  # This should be consistent with the group name in the addLegend function
#   stroke=FALSE,
#   smoothFactor=0.2,
#   fillOpacity=0.7,
#   color=~pal2(AMI_80_Pct),
#   popup=paste("Tract: ", nm_df$geoid, "<br>",
#               "Percent of HHs at 80% AMI: ", nm_df$AMI_80_Pct)
# ) %>%
#
# addLegend("bottomleft",
#           group="80% AMI Percent",  # This should be consistent with the group name in the addPolygons function
#           pal = pal2,
#           values = nm_df$AMI_80_Pct,
#           title="Percent of HHs at 80% AMI"
# ) %>%
addPolygons(
data=nm_blocks,
group="SNAP",
stroke=FALSE,
smoothFactor=0.2,
fillOpacity=0.7,
color=~pal3(snap_hh),
popup=paste("Tract: ", nm_blocks$GEOID, "<br>",
"Number of HHs Receiving SNAP: ", nm_blocks$snap_hh)
) %>%
addLegend("bottomleft",
group="SNAP",
pal = pal3,
values = nm_blocks$snap_hh,
title="Number of HHs Receiving SNAP:"
) %>%
addPolygons(
data=nm_blocks,
group="Medicaid",
stroke=FALSE,
smoothFactor=0.2,
fillOpacity=0.7,
color=~pal4(medicaid_pop),
popup=paste("Tract: ", nm_blocks$GEOID, "<br>",
"Number of HHs Receiving Medicaid: ", nm_blocks$medicaid_pop)
) %>%
addLegend("bottomleft",
group="Medicaid",
pal = pal4,
values = nm_blocks$medicaid_pop,
title="Number of HHs Receiving Medicaid:"
) %>%
addLayersControl(
overlayGroups=c( "80% AMI", "Utility Zones", "SNAP", "Medicaid"),  # Update the order for consistency
options = layersControlOptions(collapsed = FALSE)
)
map %>%
hideGroup("SNAP") %>% hideGroup("80% AMI") %>% hideGroup("Medicaid")
# nm_data <- read_excel("nm_public_housing.xlsx")
#
#
#
# library(ggmap)
#
# # Assuming your 'nm_data' dataframe has columns 'Address' and 'Address 2'
# # Create a new column to store the full address (combining Address and Address 2)
# nm_data$full_address <- paste(nm_data$Address, nm_data$`Address 2`, sep = ", ")
#
# # Use geocode() to get latitude and longitude for each address
# geocoded_data <- geocode(nm_data$full_address)
#
# # Add latitude and longitude columns to the original dataframe
# nm_data$Latitude <- geocoded_data$lat
# nm_data$Longitude <- geocoded_data$lon
#
# nm_data <- nm_data %>%?
#   filter(!is.na(Longitude))
#
# nm_data <- st_as_sf(nm_data, coords = c("Longitude", "Latitude"), crs = st_crs(nm_blocks))
# st_write(nm_data, "nm_public_housing.shp")
nm_public_housing <- st_read("nm_public_housing.shp")
# nm_public_housing_isos <- nm_public_housing %>%
#   mb_isochrone(time = 30, profile = "driving", id_column = "Name",
#                access_token = "blahblahblah"
nm_public_housing_isos_15 <- st_read("nm_public_housing_isos_15.shp")
nm_public_housing_isos_15 <- st_transform(nm_public_housing_isos_15, st_crs(nm_public_housing))
nm_public_housing_isos_30 <- st_read("nm_public_housing_isos_30.shp")
nm_public_housing_isos_30 <- st_transform(nm_public_housing_isos_30, st_crs(nm_public_housing))
library(leaflet.extras)
nm_pub_in_util <- nm_public_housing %>%
st_point_on_surface() %>%
st_join(temp_util %>% select(util_name = NAME)) %>%
filter(!is.na(util_name))
houses_in_utilies <- nm_pub_in_util$Name
iso_15 <- nm_public_housing_isos_15 %>%
filter(id %in% houses_in_utilies)
iso_30 <- nm_public_housing_isos_30 %>%
filter(id %in% houses_in_utilies)
map %>%
# addMarkers(data=nm_public_housing,
#                  group="Public Housing",
#               #   color="black",
#               #   radius=2,
#                  popup=paste("Name: ", nm_public_housing$Name)) %>%
addMarkers(data = nm_pub_in_util,
group="Public Housing",
#  color="red",
popup=paste("Name: ", nm_pub_in_util$util_name)) %>%
addPolygons(data =iso_15,
group = "15 Minute Driving",
fillOpacity = 0.2,
color = "orange") %>%
addPolygons(data =iso_30,
group = "30 Minute Driving",
fillOpacity = 0.2,
color = "darkgreen") %>%
addLayersControl(
overlayGroups=c("80% AMI", "Utility Zones", "SNAP", "Medicaid", "Public Housing", "15 Minute Driving", "30 Minute Driving"),  # Update the order for consistency
options = layersControlOptions(collapsed = FALSE)
) %>%
hideGroup("80% AMI Percent") %>% hideGroup("SNAP") %>% hideGroup("80% AMI") %>% hideGroup("Medicaid")
library(sf)
# Assuming 'snap' column is present in total_nm_tracts
# Check validity of isochrones
iso_15_valid <- st_is_valid(iso_15)
# Find indices of invalid isochrones
invalid_indices <- which(!iso_15_valid)
# Filter out invalid isochrones
valid_iso_15 <- iso_15[-invalid_indices, ]
total_nm_tracts$total_area_tract <- st_area(total_nm_tracts)
# Find the intersection of valid_iso_15 with total_nm_tracts
intersecting_tracts <- st_intersection(total_nm_tracts, valid_iso_15)
# Calculate the area of valid_iso_15 that covers each tract
intersecting_tracts$covered_area <- st_area(intersecting_tracts)
# Calculate the proportion of coverage for each tract
intersecting_tracts$proportion_coverage <- intersecting_tracts$covered_area / total_nm_tracts$total_area_tract
# If you want to consider the 'snap' column for calculating the proportion
# You can adjust the calculation based on your needs
intersecting_tracts$proportion_snap_coverage <- intersecting_tracts$proportion_coverage * intersecting_tracts$snap_hh
intersecting_tracts$proportion_medicaid_pop <- intersecting_tracts$proportion_coverage * intersecting_tracts$medicaid_pop
intersecting_tracts$proportion_80ami_coverage <- intersecting_tracts$proportion_coverage * intersecting_tracts$AMI_80
temp_15 <- intersecting_tracts %>%
st_drop_geometry() %>%
group_by(geoid) %>%
summarize(total_snap = max(snap_hh),
total_medicaid = max(medicaid_pop),
total_80ami = max(AMI_80),
covered_area = sum(proportion_coverage)) %>%
mutate(covered_prop =
case_when(
as.numeric(covered_area) >= 100 ~ 1,
TRUE ~ as.numeric(covered_area))
) %>%
mutate(
proportion_snap = covered_prop * total_snap/100,
proportion_medicaid = covered_prop * total_medicaid/100,
proportion_80ami = covered_prop * total_80ami/100,
isochrone = "15 Minute"
) %>%
group_by(isochrone) %>%
summarize(SNAP = sum(proportion_snap),
Medicaid = sum(proportion_medicaid),
LMI = sum(proportion_80ami))
temp_15
library(sf)
# Assuming 'snap' column is present in total_nm_tracts
# Check validity of isochrones
iso_30_valid <- st_is_valid(iso_30)
# Find indices of invalid isochrones
invalid_indices <- which(!iso_30_valid)
# Filter out invalid isochrones
valid_iso_30 <- iso_30[-invalid_indices, ]
total_nm_tracts$total_area_tract <- st_area(total_nm_tracts)
# Find the intersection of valid_iso_30 with total_nm_tracts
intersecting_tracts <- st_intersection(total_nm_tracts, iso_30)
ny_utils <- read.csv("~/Downloads/NYS_Electric_Utility_Service_Territories (3).csv")
View(ny_utils)
# Calculate the area of valid_iso_30 that covers each tract
intersecting_tracts$covered_area <- st_area(intersecting_tracts)
# Calculate the proportion of coverage for each tract
intersecting_tracts$proportion_coverage <- intersecting_tracts$covered_area / total_nm_tracts$total_area_tract
# If you want to consider the 'snap' column for calculating the proportion
# You can adjust the calculation based on your needs
intersecting_tracts$proportion_snap_coverage <- intersecting_tracts$proportion_coverage * intersecting_tracts$snap_hh
intersecting_tracts$proportion_medicaid_pop <- intersecting_tracts$proportion_coverage * intersecting_tracts$medicaid_pop
intersecting_tracts$proportion_80ami_coverage <- intersecting_tracts$proportion_coverage * intersecting_tracts$AMI_80
temp_30 <- intersecting_tracts %>%
st_drop_geometry() %>%
group_by(geoid) %>%
summarize(total_snap = max(snap_hh),
total_medicaid = max(medicaid_pop),
total_80ami = max(AMI_80),
covered_area = sum(proportion_coverage)) %>%
mutate(covered_prop =
case_when(
as.numeric(covered_area) >= 100 ~ 1,
TRUE ~ as.numeric(covered_area))
) %>%
mutate(
proportion_snap = covered_prop * total_snap/100,
proportion_medicaid = covered_prop * total_medicaid/100,
proportion_80ami = covered_prop * total_80ami/100,
isochrone = "30 Minute"
) %>%
group_by(isochrone) %>%
summarize(SNAP = sum(proportion_snap),
Medicaid = sum(proportion_medicaid),
LMI = sum(proportion_80ami))
temp_30
temp <- rbind(temp_15, temp_30)
datatable(temp, caption = "New Mexico Distance from Public Housing and Selected Characteristics")%>%
formatCurrency('SNAP',currency = "", interval = 3, mark = ",") %>%
formatCurrency('Medicaid',currency = "", interval = 3, mark = ",") %>%
formatCurrency('LMI',currency = "", interval = 3, mark = ",")
library(xml2)
library(dplyr)
url <- "https://data.ny.gov/resource/awza-4vgu.xml"
xml_data <- read_xml(url)
rows <- xml_find_all(xml_data, ".//row")
data_list <- lapply(rows, function(row) {
comp_full <- xml_text(xml_find_first(row, ".//comp_full"))
comp_short <- xml_text(xml_find_first(row, ".//comp_short"))
the_geom <- xml_text(xml_find_first(row, ".//the_geom"))
comp_id <- xml_text(xml_find_first(row, ".//comp_id"))
datemod <- as.POSIXct(as.numeric(xml_text(xml_find_first(row, ".//datemod"))), origin = "1970-01-01")
data.frame(
comp_full = comp_full,
comp_short = comp_short,
the_geom = the_geom,
comp_id = comp_id,
datemod = datemod,
stringsAsFactors = FALSE
)
})
ny_util <- do.call(rbind, data_list)
View(ny_utils)
# Convert the_geom column to sf geometries
ny_geom <- st_as_sfc(ny_util$the_geom)
# Create the sf object by combining geometries and attributes
ny_sf <- st_sf(ny_util, geometry = sf_geom)
st_crs(ny_sf) <- st_crs(ny_blocks)
ny_sf
st_crs(ny_sf)
ny_utils <- read.csv("~/Downloads/NYS_Electric_Utility_Service_Territories (3).csv")
# Convert the_geom column to sf geometries
ny_geom <- st_as_sfc(ny_util$the_geom)
# Create the sf object by combining geometries and attributes
ny_sf <- st_sf(ny_util, geometry = sf_geom)
st_crs(ny_sf) <- st_crs(ny_blocks)
library(leaflet)
leaflet() %>%
addPolygons(ny_sf)
st_crs(ny_sf)
st_crs(ny_blocks)
st_write(ny_sf, "ny_utils.shp")
ny_utils <- st_read("ny_utils.shp")
library(leaflet)
leaflet() %>%
addPolygons(ny_sf)
View(ny_utils)
library(leaflet)
leaflet() %>%
addPolygons(ny_blocks)
chas_df <- load_chas() %>%
mutate(State_Name = case_when(
state == 17 ~ "Illinois",
state == 25 ~ "Massachusetts",
state == 27 ~ "Minnesota",
state == 34 ~ "New Jersey",
state == 35 ~ "New Mexico",
state == 36 ~ "New York",
TRUE ~ "Other"
))
add_geo <- merge(chas_df, get_tracts)
add_geo <- st_as_sf(add_geo)
add_geo <- add_geo %>%
filter(State_Name=="New York")
temp_util <- st_transform(temp_util, st_crs(add_geo)) %>%
st_make_valid()
library(sf)
library(leaflet)
# Read the spatial data
nat_grid <- st_read("/Users/jacobford/Desktop/nat_grid_zone_e.shp")
library(sf)
library(leaflet)
# Read the spatial data
nat_grid <- st_read("/Users/jacobford/Library/CloudStorage/GoogleDrive-jake@solstice.us/Shared drives/Product | Jake/Geocoding/New York/Zone E Boundary/nat_grid_zone_e.shp")
library(sf)
library(leaflet)
# Read the spatial data
nat_grid <- st_read("/Users/jacobford/Library/CloudStorage/GoogleDrive-jake@solstice.us/Shared drives/Product | Jake/Geocoding/New York/Zone E Boundary/NY Zone E.shp")
# Remove the Z dimension
nat_grid_xy <- st_zm(nat_grid, drop = TRUE)
# Define your color palette and values
pal5 <- colorFactor(
palette="viridis",
domain=temp_util$new_name
)
# Create the leaflet map
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(data = temp_util,
group = "Utility Zones",
stroke = TRUE,
color = ~pal5(temp_util$new_name),
dashArray = "3",
fillOpacity = 0.5,
popup = paste("Utility Zone: ", temp_util$new_name)) %>%
addPolygons(data = nat_grid_xy,
fillColor = "blue",
color = "black",
fillOpacity = 0.4,
group = "NatGrid Zone E") %>%
addLegend(
position = "bottomright",   # Position of the legend on the map
colors = "blue",             # Color(s) to show in the legend
labels = "NatGrid Zone E",   # Label for the legend
opacity = 0.4               # Fill opacity for the legend color
) %>%
addLegend(position = "bottomright",
pal = pal5,
values = temp_util$new_name,
title = "Solstice NY Utilities")
ny_utils <- st_read("ny_utils.shp")
ny_utils_xy <- st_zm(ny_utils, drop = TRUE)
nat_grid <- st_read("/Users/jacobford/Library/CloudStorage/GoogleDrive-jake@solstice.us/Shared drives/Product | Jake/Geocoding/New York/Zone E Boundary/NY Zone E.shp")
st_crs(temp_util)
ny_utils <- st_read("ny_utils.shp")
ny_utils_xy <- st_zm(ny_utils, drop = TRUE)
leaflet() %>%
addPolygons( data = ny_utils_xy)
View(ny_util)
head(ny_utils$comp_full)
head(ny_utils$comp_short)
ny_utils <- st_read("ny_utils.shp") %>%
filter(grepl(c("NGRID", "NYSEG", "CHGE", "RGE", "ORU"), comp_short))
ny_utils <- st_read("ny_utils.shp") %>%
filter(grepl(c("NGRID", "NYSEG", "CHGE", "RGE", "ORU", sep="|"), comp_short))
View(ny_utils)
ny_utils <- st_read("ny_utils.shp") %>%
filter(grepl("NGRID|NYSEG|CHGE|RGE|ORU", comp_short))
View(ny_utils)
library(sf)
library(leaflet)
ny_utils <- st_read("ny_utils.shp") %>%
filter(grepl("NGRID|NYSEG|CHGE|RGE|ORU", comp_short))
ny_utils_xy <- st_zm(ny_utils, drop = TRUE)
# Define your color palette and values
pal5 <- colorFactor(
palette="viridis",
domain=ny_utils_xy$comp_long
)
# Create the leaflet map
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(data = ny_utils_xy,
group = "Utility Zones",
stroke = TRUE,
color = ~pal5(ny_utils_xy$comp_long),
dashArray = "3",
fillOpacity = 0.5,
popup = paste("Utility Zone: ", ny_utils_xy$comp_long)) %>%
addPolygons(data = nat_grid_xy,
fillColor = "blue",
color = "black",
fillOpacity = 0.4,
group = "NatGrid Zone E") %>%
addLegend(
position = "bottomright",   # Position of the legend on the map
colors = "blue",             # Color(s) to show in the legend
labels = "NatGrid Zone E",   # Label for the legend
opacity = 0.4               # Fill opacity for the legend color
) %>%
addLegend(position = "bottomright",
pal = pal5,
values = ny_utils_xy$comp_long,
title = "Solstice NY Utilities")
table(ny_utils_xy$comp_full)
library(sf)
library(leaflet)
ny_utils <- st_read("ny_utils.shp") %>%
filter(grepl("NGRID|NYSEG|CHGE|RGE|ORU", comp_short))
ny_utils_xy <- st_zm(ny_utils, drop = TRUE)
# Define your color palette and values
pal5 <- colorFactor(
palette="viridis",
domain=ny_utils_xy$comp_full
)
# Create the leaflet map
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(data = ny_utils_xy,
group = "Utility Zones",
stroke = TRUE,
color = ~pal5(ny_utils_xy$comp_full),
dashArray = "3",
fillOpacity = 0.5,
popup = paste("Utility Zone: ", ny_utils_xy$comp_full)) %>%
addLegend(position = "bottomright",
pal = pal5,
values = ny_utils_xy$comp_full,
title = "Solstice NY Utilities")
library(sf)
library(leaflet)
temp_util <- st_read("ny_utils.shp") %>%
filter(grepl("NGRID|NYSEG|CHGE|RGE|ORU", comp_short))
temp_util <- st_zm(temp_util, drop = TRUE)
# Define your color palette and values
pal5 <- colorFactor(
palette="viridis",
domain=temp_util$comp_full
)
# Create the leaflet map
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(data = temp_util,
group = "Utility Zones",
stroke = TRUE,
color = ~pal5(temp_util$comp_full),
dashArray = "3",
fillOpacity = 0.5,
popup = paste("Utility Zone: ", temp_util$comp_full)) %>%
addLegend(position = "bottomright",
pal = pal5,
values = temp_util$comp_full,
title = "Solstice NY Utilities")
ny_blocks <- get_acs(
geography="tract",
state="NY",
variables=c("snap_hh" = "B22001_002",
"snap_pop" = "B19058_002",
"medicaid_1" = "C27007_004",
"medicaid_2" = "C27007_007",
"medicaid_3" = "C27007_010",
"medicaid_4" = "C27007_014",
"medicaid_5" = "C27007_017",
"medicaid_6" = "C27007_020",
"Total_Pop" = "B01001_001"
),
year=2019,
geometry=TRUE) %>%
group_by(GEOID) %>%
summarize(
#snap_hh = estimate[variable=="snap_pop"],
#medicaid_pop =estimate[variable=="medicaid_1"] +
#             estimate[variable=="medicaid_2"] +
#            estimate[variable=="medicaid_3"] +
#           estimate[variable=="medicaid_4"] +
#          estimate[variable=="medicaid_5"] +
#         estimate[variable=="medicaid_6"] ,
total_pop = estimate[variable=="Total_Pop"])
total_nm_tracts <- cbind(add_geo, ny_blocks)
ny_blocks
