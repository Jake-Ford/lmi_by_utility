overlayGroups=c( "80% AMI", "Utility Zones", "SNAP", "Medicaid"),  # Update the order for consistency
options = layersControlOptions(collapsed = FALSE)
)
map %>%
hideGroup("SNAP") %>% hideGroup("80% AMI") %>% hideGroup("Medicaid")
# nm_data <- read_excel("data/nm/nm_public_housing.xlsx")
#
#
#
# library(ggmap)
#
# # Assuming your 'nm_data' dataframe has columns 'Address' and 'Address 2'
# # Create a new column to store the full address (combining Address and Address 2)
# nm_data$full_address <- paste(nm_data$Address, nm_data$`Address 2`, sep = ", ")
#
# # Use geocode() to get latitude and longitude for each address
# geocoded_data <- geocode(nm_data$full_address)
#
# # Add latitude and longitude columns to the original dataframe
# nm_data$Latitude <- geocoded_data$lat
# nm_data$Longitude <- geocoded_data$lon
#
# nm_data <- nm_data %>%?
#   filter(!is.na(Longitude))
#
# nm_data <- st_as_sf(nm_data, coords = c("Longitude", "Latitude"), crs = st_crs(nm_blocks))
# st_write(nm_data, "nm_public_housing.shp")
nm_public_housing <- st_read("data/nm/nm_public_housing.shp")
# nm_public_housing_isos <- nm_public_housing %>%
#   mb_isochrone(time = 30, profile = "driving", id_column = "Name",
#                access_token = "blahblahblah"
nm_public_housing_isos_15 <- st_read("isochrones/nm_public_housing_isos_15.shp")
nm_public_housing_isos_15 <- st_transform(nm_public_housing_isos_15, st_crs(nm_public_housing))
nm_public_housing_isos_30 <- st_read("isochrones/nm_public_housing_isos_30.shp")
nm_public_housing_isos_30 <- st_transform(nm_public_housing_isos_30, st_crs(nm_public_housing))
library(leaflet.extras)
nm_pub_in_util <- nm_public_housing %>%
st_point_on_surface() %>%
st_join(temp_util %>% select(util_name = NAME)) %>%
filter(!is.na(util_name))
houses_in_utilies <- nm_pub_in_util$Name
iso_15 <- nm_public_housing_isos_15 %>%
filter(id %in% houses_in_utilies)
iso_30 <- nm_public_housing_isos_30 %>%
filter(id %in% houses_in_utilies)
map %>%
# addMarkers(data=nm_public_housing,
#                  group="Public Housing",
#               #   color="black",
#               #   radius=2,
#                  popup=paste("Name: ", nm_public_housing$Name)) %>%
addMarkers(data = nm_pub_in_util,
group="Public Housing",
#  color="red",
popup=paste("Name: ", nm_pub_in_util$util_name)) %>%
addPolygons(data =iso_15,
group = "15 Minute Driving",
fillOpacity = 0.2,
color = "orange") %>%
addPolygons(data =iso_30,
group = "30 Minute Driving",
fillOpacity = 0.2,
color = "darkgreen") %>%
addLayersControl(
overlayGroups=c("80% AMI", "Utility Zones", "SNAP", "Medicaid", "Public Housing", "15 Minute Driving", "30 Minute Driving"),  # Update the order for consistency
options = layersControlOptions(collapsed = FALSE)
) %>%
hideGroup("80% AMI Percent") %>% hideGroup("SNAP") %>% hideGroup("80% AMI") %>% hideGroup("Medicaid")
# Assuming 'snap' column is present in total_nm_tracts
# Check validity of isochrones
iso_15_valid <- st_is_valid(iso_15)
# Find indices of invalid isochrones
invalid_indices <- which(!iso_15_valid)
# Filter out invalid isochrones
valid_iso_15 <- iso_15[-invalid_indices, ]
total_nm_tracts$total_area_tract <- st_area(total_nm_tracts)
# Find the intersection of valid_iso_15 with total_nm_tracts
intersecting_tracts <- st_intersection(total_nm_tracts, valid_iso_15)
# Calculate the area of valid_iso_15 that covers each tract
intersecting_tracts$covered_area <- st_area(intersecting_tracts)
# Calculate the proportion of coverage for each tract
intersecting_tracts$proportion_coverage <- intersecting_tracts$covered_area / total_nm_tracts$total_area_tract
# If you want to consider the 'snap' column for calculating the proportion
# You can adjust the calculation based on your needs
intersecting_tracts$proportion_snap_coverage <- intersecting_tracts$proportion_coverage * intersecting_tracts$snap_hh
intersecting_tracts$proportion_medicaid_pop <- intersecting_tracts$proportion_coverage * intersecting_tracts$medicaid_pop
intersecting_tracts$proportion_80ami_coverage <- intersecting_tracts$proportion_coverage * intersecting_tracts$AMI_80
intersecting_tracts$proportion_total_pop <- intersecting_tracts$proportion_coverage * intersecting_tracts$total_pop
temp_15 <- intersecting_tracts %>%
st_drop_geometry() %>%
group_by(geoid) %>%
summarize(total_snap = max(snap_hh),
total_medicaid = max(medicaid_pop),
total_80ami = max(AMI_80),
covered_area = sum(proportion_coverage),
total_pop = max(total_pop)) %>%
mutate(covered_prop =
case_when(
as.numeric(covered_area) >= 100 ~ 1,
TRUE ~ as.numeric(covered_area))
) %>%
mutate(
proportion_snap = covered_prop * total_snap/100,
proportion_medicaid = covered_prop * total_medicaid/100,
proportion_80ami = covered_prop * total_80ami/100,
proportion_total_pop = covered_prop * total_pop/100,
isochrone = "15 Minute"
) %>%
group_by(isochrone) %>%
summarize(SNAP = sum(proportion_snap),
Medicaid = sum(proportion_medicaid),
LMI = sum(proportion_80ami),
Total_Pop = sum(proportion_total_pop))
temp_15
# Assuming 'snap' column is present in total_nm_tracts
# Check validity of isochrones
iso_30_valid <- st_is_valid(iso_30)
# Find indices of invalid isochrones
invalid_indices <- which(!iso_30_valid)
# Filter out invalid isochrones
valid_iso_30 <- iso_30[-invalid_indices, ]
total_nm_tracts$total_area_tract <- st_area(total_nm_tracts)
# Find the intersection of valid_iso_30 with total_nm_tracts
intersecting_tracts <- st_intersection(total_nm_tracts, iso_30)
# Calculate the area of valid_iso_30 that covers each tract
intersecting_tracts$covered_area <- st_area(intersecting_tracts)
# Calculate the proportion of coverage for each tract
intersecting_tracts$proportion_coverage <- intersecting_tracts$covered_area / total_nm_tracts$total_area_tract
# If you want to consider the 'snap' column for calculating the proportion
# You can adjust the calculation based on your needs
intersecting_tracts$proportion_snap_coverage <- intersecting_tracts$proportion_coverage * intersecting_tracts$snap_hh
intersecting_tracts$proportion_medicaid_pop <- intersecting_tracts$proportion_coverage * intersecting_tracts$medicaid_pop
intersecting_tracts$proportion_80ami_coverage <- intersecting_tracts$proportion_coverage * intersecting_tracts$AMI_80
intersecting_tracts$proportion_total_pop <- intersecting_tracts$proportion_coverage * intersecting_tracts$total_pop
temp_30 <- intersecting_tracts %>%
st_drop_geometry() %>%
group_by(geoid) %>%
summarize(total_snap = max(snap_hh),
total_medicaid = max(medicaid_pop),
total_80ami = max(AMI_80),
covered_area = sum(proportion_coverage),
total_pop = max(total_pop)) %>%
mutate(covered_prop =
case_when(
as.numeric(covered_area) >= 100 ~ 1,
TRUE ~ as.numeric(covered_area))
) %>%
mutate(
proportion_snap = covered_prop * total_snap/100,
proportion_medicaid = covered_prop * total_medicaid/100,
proportion_80ami = covered_prop * total_80ami/100,
proportion_total_pop = covered_prop * total_pop/100,
isochrone = "30 Minute"
) %>%
group_by(isochrone) %>%
summarize(SNAP = sum(proportion_snap),
Medicaid = sum(proportion_medicaid),
LMI = sum(proportion_80ami),
Total_Pop = sum(proportion_total_pop))
temp_30
temp <- rbind(temp_15, temp_30)
datatable(temp, caption = "New Mexico Distance from Public Housing and Selected Characteristics")%>%
formatCurrency('LMI',currency = "", interval = 3, mark = ",") %>%
formatCurrency('Medicaid',currency = "", interval = 3, mark = ",") %>%
formatCurrency('SNAP',currency = "", interval = 3, mark = ",")  %>%
formatCurrency('Total_Pop', currency="", interval = 3, mark = ",")
#  * NYSERDA [Supported Solar Projects](https://www.nyserda.ny.gov/All-Programs/NY-Sun/Solar-Data-Maps/NYSERDA-Supported-Solar-Projects)
chas_df <- load_chas() %>%
mutate(State_Name = case_when(
state == 17 ~ "Illinois",
state == 25 ~ "Massachusetts",
state == 27 ~ "Minnesota",
state == 34 ~ "New Jersey",
state == 35 ~ "New Mexico",
state == 36 ~ "New York",
TRUE ~ "Other"
))
add_geo <- merge(chas_df, get_tracts)
add_geo <- st_as_sf(add_geo)
add_geo <- add_geo %>%
filter(State_Name=="New York")
temp_util <- st_read("data/NY/ny_utils.shp") %>%
filter(grepl("NGRID|NYSEG|CHGE|RGE|ORU", comp_short))
dac_bgs <- st_read("data/NY/Interim Disadvantaged Communities (DAC)_ 2020/geo_export_ae5e9c30-45bc-4888-87dd-681a41d761d8.shp")
lift_df <- read.csv("data/groundswell_lift/cs-projects-2023-08-18.csv")
lift_df <- separate(lift_df, GeoCode, into = c("long", "lat"), sep = ",")
lift_df <- st_as_sf(lift_df, coords = c("long", "lat"), crs = st_crs(nm_blocks))
temp_util <- st_zm(temp_util, drop = TRUE)
pal5 <- colorFactor(
palette="viridis",
domain=temp_util$comp_full
)
# Create the leaflet map
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(data = temp_util,
group = "Utility Zones",
stroke = TRUE,
color = ~pal5(temp_util$comp_full),
dashArray = "3",
fillOpacity = 0.5,
popup = paste("Utility Zone: ", temp_util$comp_full)) %>%
addLegend(position = "bottomright",
pal = pal5,
values = temp_util$comp_full,
title = "Solstice NY Utilities") %>%
addPolygons(data = dac_bgs,
group="DAC") %>%
addLayersControl(
overlayGroups=c( "Utility Zones", "DAC"),  # Update the order for consistency
options = layersControlOptions(collapsed = FALSE)
)
dac_bgs <- st_transform(dac_bgs, st_crs(total_nm_tracts)) %>% st_make_valid()
temp <- dac_bgs %>%
st_point_on_surface() %>%
st_make_valid() %>%
st_join(temp_util %>% select(comp_full)) %>%
st_drop_geometry() %>%
group_by(Name = comp_full) %>%
filter(!is.na(Name)) %>%
summarize(Population = sum(pop_2018)
) %>%
arrange(desc(Population))
datatable(temp, caption = "Interim Disadvantaged Communities (DAC) Population by Utiliy Zone")%>%
formatCurrency('Population',currency = "", interval = 3, mark = ",")
ny_tracts <- get_acs(
geography="tract",
state="NY",
variables=c("Total_Pop" = "B01001_001","snap_hh" = "B22001_002","snap_pop" = "B19058_002"
),
year=2019,
geometry=TRUE) %>%
group_by(GEOID) %>%
summarize(total_pop = estimate[variable=="Total_Pop"],
snap_hh = estimate[variable=="snap_hh"],
snap_pop = estimate[variable=="snap_pop"])
# ny_bgs <- get_acs(
#   geography="block group",
#   state="NY",
#   variables=c("Total_Pop" = "B01001_001"),
#   year=2019,
#   geometry=TRUE)
#
# lmi_data <- read_excel("data/NY/ny-lowmod-blockgroup.xls")
total_ny_tracts <- cbind(add_geo, ny_tracts)
temp <- total_ny_tracts %>%
st_point_on_surface() %>%
st_make_valid() %>%
st_join(temp_util %>% select(comp_short)) %>%
st_drop_geometry() %>%
group_by(Name = comp_short) %>%
filter(!is.na(Name)) %>%
summarize(`Pop under 80 AMI` = sum(AMI_80),
`SNAP HH` = sum(snap_hh),
`Total Population` = sum(total_pop)) %>%
arrange(desc(`Pop under 80 AMI`))
datatable(temp, caption = "New York, Sources: ACS 2019 and HUD CHAS")%>%
formatCurrency('Pop under 80 AMI',currency = "", interval = 3, mark = ",") %>%
formatCurrency('SNAP HH',currency = "", interval = 3, mark = ",") %>%
formatCurrency('Total Population',currency = "", interval = 3, mark = ",")
ny_df <- add_geo %>%
filter(State_Name == "New York")
pal <- colorNumeric(
palette = "viridis",
# reverse=TRUE,
domain = ny_df$AMI_80)
pal2 <- colorNumeric(
palette = "Purples",
# reverse=TRUE,
domain = ny_df$AMI_80_Pct)
pal3 <- colorNumeric(
palette = "viridis",
# reverse=TRUE,
domain = total_ny_tracts$snap_hh)
library(tidyr)
ny_lift <- lift_df %>%
filter(State=="New York")
map <- leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(data=temp_util,
group="Utility Zones",
stroke=TRUE,
color="black",
dashArray="3",
fillOpacity=0,
popup=paste("Utility Zone: ", temp_util$comp_short)
) %>%
addPolygons(
data = ny_df,
group="80% AMI",  # This should be consistent with the group name in the addLegend function
stroke=FALSE,
smoothFactor=0.2,
fillOpacity=0.85,
color=~pal(AMI_80),
popup=paste("Tract: ", ny_df$geoid, "<br>",
"HHs at 80% AMI: ", ny_df$AMI_80)
) %>%
addLegend("bottomleft",
group="80% AMI",  # This should be consistent with the group name in the addPolygons function
pal = pal,
values = ny_df$AMI_80,
title="Number of HHs at 80% AMI"
) %>%
# addPolygons(
#   data=nm_df,
#   group="80% AMI Percent",  # This should be consistent with the group name in the addLegend function
#   stroke=FALSE,
#   smoothFactor=0.2,
#   fillOpacity=0.7,
#   color=~pal2(AMI_80_Pct),
#   popup=paste("Tract: ", nm_df$geoid, "<br>",
#               "Percent of HHs at 80% AMI: ", nm_df$AMI_80_Pct)
# ) %>%
#
# addLegend("bottomleft",
#           group="80% AMI Percent",  # This should be consistent with the group name in the addPolygons function
#           pal = pal2,
#           values = nm_df$AMI_80_Pct,
#           title="Percent of HHs at 80% AMI"
# ) %>%
addPolygons(
data=total_ny_tracts,
group="SNAP",
stroke=FALSE,
smoothFactor=0.2,
fillOpacity=0.7,
color=~pal3(snap_hh),
popup=paste("Tract: ", total_ny_tracts$GEOID, "<br>",
"Number of HHs Receiving SNAP: ", total_ny_tracts$snap_hh)
) %>%
addLegend("bottomleft",
group="SNAP",
pal = pal3,
values = total_ny_tracts$snap_hh,
title="Number of HHs Receiving SNAP:"
) %>%
addLayersControl(
overlayGroups=c( "80% AMI", "Utility Zones", "SNAP"),  # Update the order for consistency
options = layersControlOptions(collapsed = FALSE)
)
map %>%
hideGroup("SNAP") %>% hideGroup("80% AMI")
ny_df <- add_geo %>%
filter(State_Name == "New York")
ny_lift <- lift_df %>%
filter(State == "New York")
pal_potLMI <- colorNumeric(
palette = "viridis",
# reverse=TRUE,
domain = ny_lift$Potential...LMI.Subscribers)
pal_cap <- colorNumeric(
palette = "viridis",
# reverse=TRUE,
domain = ny_lift$Project.Capacity.KW.AC)
pal <- colorNumeric(
palette = "viridis",
# reverse=TRUE,
domain = ny_df$AMI_80)
pal2 <- colorNumeric(
palette = "Purples",
# reverse=TRUE,
domain = ny_df$AMI_80_Pct)
pal3 <- colorNumeric(
palette = "viridis",
# reverse=TRUE,
domain = total_ny_tracts$snap_hh)
library(tidyr)
ny_lift <- lift_df %>%
filter(State=="New York")
map <- leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(data=temp_util,
group="Utility Zones",
stroke=TRUE,
color="black",
dashArray="3",
fillOpacity=0,
popup=paste("Utility Zone: ", temp_util$comp_short)
) %>%
addPolygons(
data = ny_df,
group="80% AMI",  # This should be consistent with the group name in the addLegend function
stroke=FALSE,
smoothFactor=0.2,
fillOpacity=0.85,
color=~pal(AMI_80),
popup=paste("Tract: ", ny_df$geoid, "<br>",
"HHs at 80% AMI: ", ny_df$AMI_80)
) %>%
addLegend("bottomleft",
group="80% AMI",  # This should be consistent with the group name in the addPolygons function
pal = pal,
values = ny_df$AMI_80,
title="Number of HHs at 80% AMI"
) %>%
# addPolygons(
#   data=nm_df,
#   group="80% AMI Percent",  # This should be consistent with the group name in the addLegend function
#   stroke=FALSE,
#   smoothFactor=0.2,
#   fillOpacity=0.7,
#   color=~pal2(AMI_80_Pct),
#   popup=paste("Tract: ", nm_df$geoid, "<br>",
#               "Percent of HHs at 80% AMI: ", nm_df$AMI_80_Pct)
# ) %>%
#
# addLegend("bottomleft",
#           group="80% AMI Percent",  # This should be consistent with the group name in the addPolygons function
#           pal = pal2,
#           values = nm_df$AMI_80_Pct,
#           title="Percent of HHs at 80% AMI"
# ) %>%
addPolygons(
data=total_ny_tracts,
group="SNAP",
stroke=FALSE,
smoothFactor=0.2,
fillOpacity=0.7,
color=~pal3(snap_hh),
popup=paste("Tract: ", total_ny_tracts$GEOID, "<br>",
"Number of HHs Receiving SNAP: ", total_ny_tracts$snap_hh)
) %>%
addLegend("bottomleft",
group="SNAP",
pal = pal3,
values = total_ny_tracts$snap_hh,
title="Number of HHs Receiving SNAP:"
) %>%
addCircleMarkers(data = ny_lift,
group="Potential LMI Subscribers",
popup = ~paste("Program Name: ", Program.Name, "<br>",
"Developer/Owner: ", Project.Developer.or.Owner, "<br>",
"Project Capacity: ", Project.Capacity.KW.AC, "<br>",
"LMI Savings: ", LMI.Customer.Savings.., "<br>",
"Potential LMI Subscribers: ", Potential...LMI.Subscribers),
radius = ny_lift$Potential...LMI.Subscribers/15,
color = ~pal_potLMI(Potential...LMI.Subscribers)) %>%
addLegend("bottomright",
group="Potential LMI Subscribers",  # This should be consistent with the group name in the addPolygons function
pal = pal_potLMI,
values = ny_lift$Potential...LMI.Subscribers,
title="Potential LMI Subscribers") %>%
## Project Capacity ##
addCircleMarkers(data = ny_lift,
group="Project Capacity",
popup = ~paste("Program Name: ", Program.Name, "<br>",
"Developer/Owner: ", Project.Developer.or.Owner, "<br>",
"Project Capacity: ", Project.Capacity.KW.AC, "<br>",
"LMI Savings: ", LMI.Customer.Savings.., "<br>",
"Potential LMI Subscribers: ", Potential...LMI.Subscribers),
radius = ny_lift$Project.Capacity.KW.AC/100,
color = ~pal_cap(Project.Capacity.KW.AC)) %>%
addLegend("topleft",
group="Project Capacity",  # This should be consistent with the group name in the addPolygons function
pal = pal_cap,
values = ny_lift$Project.Capacity.KW.AC,
title="Project Capacity") %>%
addLayersControl(
overlayGroups=c( "80% AMI", "Utility Zones", "SNAP","Potential LMI Subscribers", "Project Capacity"),  # Update the order for consistency
options = layersControlOptions(collapsed = FALSE)
)
map %>%
hideGroup("SNAP") %>% hideGroup("80% AMI") %>% hideGroup("Project Capacity")
chas_df <- load_chas() %>%
mutate(State_Name = case_when(
state == 17 ~ "Illinois",
state == 25 ~ "Massachusetts",
state == 27 ~ "Minnesota",
state == 34 ~ "New Jersey",
state == 35 ~ "New Mexico",
state == 36 ~ "New York",
state == 06 ~ "California",
TRUE ~ "Other"
))
add_geo <- merge(chas_df, get_tracts)
add_geo <- st_as_sf(add_geo)
add_geo <- add_geo %>%
filter(State_Name=="California")
# CalEnviroScreen Data Download
#%>%
# filter(CIscoreP >= 75) %>%
# st_drop_geometry()
ca_tracts <- get_acs(
geography="tract",
state="CA",
variables=c("Total_Pop" = "B01001_001"
),
year=2019,
geometry=TRUE)
ca_tracts$Tract <- as.double(ca_tracts$GEOID)
env_df <- st_read("/Users/jacobford/Downloads/calenviroscreen40shpf2021shp/CES4 Final Shapefile.shp")
env_df <- st_transform(env_df, crs = st_crs(ca_tracts))
pal <- colorNumeric(
palette = "viridis",
domain = env_df$CIscoreP[env_df$CIscoreP >=75],
reverse = TRUE
)
env_df %>%
filter(CIscoreP >= 75) %>%
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(
# color = ~pal(CIscoreP),
stroke=FALSE,
smoothFactor=0.2,
fillOpacity=0.7,
color=~pal(CIscoreP),
popup = paste("GEOID: ", env_df$Tract, "<br>",
"Total Population: ", env_df$TotPop19, "<br>",
"EnviroScreen 4.0 Score: ", env_df$CIscore, "<br>",
"EnviroScreen 4.0 Score Percentile: ", env_df$CIscoreP
))
