---
title: "LMI Population Spatial Analysis"
subtitle: "Solstice"
author: "Jacob Ford, Data Scientist"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  rmdformats::material
---



# Overview

This document quantifies the number of income and geographic qualified population in each state Solstice operates in. Utiliy zones are overlaid with these populations to estimate the potential population Solstice would be competing to sign up.The goal of this work is to quantify the potential market for LMI population for future Solstice bidding opportunities. 

Utility coverage is provided by either the [HIFLD](https://hifld-geoplatform.opendata.arcgis.com/datasets/f4cd55044b924fed9bc8b64022966097/explore?location=41.065293%2C-80.583661%2C6.90) national level electric retail service territories or, preferably, state sources that are more granular. Note HIFLD often provides overlapping areas (ex: a municipal boundary and an utility provider) so data should primarily be sourced from state sources or be validated from HIFLD. 

Please refer to the [policy matrix](https://coda.io/d/Solstice-Policy_dBUL-zOSfnb/Program-Matrix_suVJB#Program-Matrix_tuLIr/r11&view=full) on Coda for further details on state specific LMI and geoqualification methods. Read more about our state programs on the [Solstice homepage](https://solstice.us/). 


```{r message=FALSE, warning=FALSE, include=FALSE}
#Load packages we'll need throughout the entire document
library(readxl)
library(data.table)
library(DT)
library(sf)
library(mapview)
library(dplyr)
library(scales)
library(tidycensus)
library(tidyverse)
options(tigris_use_cache = TRUE)
library(nngeo)
library(leaflet)
library(janitor)
library(DT)
library(kableExtra)
library(ggmap)
source('helper_functions.R')
library(RColorBrewer)

library(tidyr)
options(scipen = 100)

```



# New Mexico

```{r message=FALSE, warning=FALSE, include=FALSE}

state_list <- c("IL", "MA", "MN", "NJ", "NM", "NY",  "CA", "DE")

hifld_df <- st_read("utility_zones/HIFLD/Electric_Retail_Service_Territories (1)/Electric_Retail_Service_Territories.shp") 

temp_util <- hifld_df %>%
  filter(ID %in% c(15473, 10817, 5701)) %>%
  mutate(new_name = case_when(
    ID == 15473 ~ "Public Service Company",
    ID == 10817 ~ "Xcel",
    ID == 5701 ~ "El Paso Electric"
  ))
census_api_key('ba3d95cae3658f3145daf7f66119ed58a52aaca3')

get_tracts <- get_acs(
  geography="tract", 
  state=state_list,
  variables=c("Median Income" = "S1901_C01_012E"),
  year=2017, 
  geometry=TRUE) %>%
  mutate(MedInc = estimate) %>%
  select(geoid=GEOID, geometry)


```




## Geoqualification

In New Mexico, there is no geographic qualification methods, so we only focus on estimating the potential LMI population by various methods used in the state program. 




```{r message=FALSE, warning=FALSE, include=FALSE}
chas_df <- load_chas() %>%
    mutate(State_Name = case_when(
    state == 17 ~ "Illinois",
    state == 25 ~ "Massachusetts",  
    state == 27 ~ "Minnesota",  
    state == 34 ~ "New Jersey",
    state == 35 ~ "New Mexico",  
    state == 36 ~ "New York",
    state == 06 ~ "California",
    TRUE ~ "Other"
  ))



add_geo <- merge(chas_df, get_tracts) 

add_geo <- st_as_sf(add_geo)

nm_geo <- add_geo %>%
  filter(State_Name=="New Mexico")

temp_util <- st_transform(temp_util, st_crs(nm_geo)) %>%
  st_make_valid()
```

## LMI Qualifications


New Mexico LMI Qualification methods include:


  * Medicaid
  * SNAP
  * LIHEAP
  * First-time home owner programs
  * Affordable housing facilities
    - HUD data ([potential example](https://resources.hud.gov/#layers-menu))
    - State specific ([potential example](https://housingnm.org/find-housing/rentals/affordable))
  * State and federal income tax credit
  * Entire multi-family housing project may qualify if the entire load can be proved to be low-income subscribers, with consent of all tenants of record.
  * **LMI - 80% of AMI**
  

Census data is available for the population receiving Medicaid, SNAP, and number of households at or below 80% AMI. The following analysis quantifies the total eligible LMI population by each of these three categories.

Solstice operates in the following three utility zones in New Mexico:

  * Public Service Company of New Mexico
  * Excel
  * El Paso Electric

```{r echo=FALSE, message=FALSE, warning=FALSE}

pal5 <- colorFactor(
  palette="viridis",
  domain=temp_util$new_name
)

leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data=temp_util,
              group="Utility Zones",
              stroke=TRUE,
              color=~pal5(temp_util$new_name),
              dashArray="3",
              fillOpacity=0.5,
              popup=paste("Utility Zone: ", temp_util$new_name)) %>%
  addLegend(position="bottomright",
            pal=pal5,
            values=temp_util$new_name,
            title="Solstice NM Utilities")
```
  


```{r message=FALSE, warning=FALSE, include=FALSE}

  # * Medicaid
  #   - total count of population with Medicaid- C27007_004 + C27007_007 + C27007_010 + C27007_014 + C27007_017 + C27007_020
  #   - geo: tract
  #   
  # * SNAP
  #   - total count of HH received Food Stamps/SNAP in last 12 months - B22001_002
  #   - total count of population received Food Stamps/SNAP in last 12 months - B19058_002
  #   - geo: tract
  # * LIHEAP
  #   - use this to calculate income by self attestation? 
  #   https://www.acf.hhs.gov/sites/default/files/documents/ocs/comm_liheap_im2002smiattachment_fy2021.pdf
  #   
  # * first-time home owner programs
  # * affordable housing facilities
  #   - HUD data: https://resources.hud.gov/#layers-menu
  #   - state specific to supplement: https://housingnm.org/find-housing/rentals/affordable
  # * low-income housing
  # * state and federal income tax credit
  # * entire multi-family housing project may qualify if the entire load can be proved to be low-income subscribers, with consent of all tenants of record.
  # 
  # LMI - 80% of AMI from HUD..
# acs_vars <- load_variables(2019, "acs5")

nm_blocks <- get_acs(
  geography="tract", 
  state="NM",
  variables=c("snap_hh" = "B22001_002",
              "snap_pop" = "B19058_002",
              "medicaid_1" = "C27007_004",
              "medicaid_2" = "C27007_007",
              "medicaid_3" = "C27007_010",
              "medicaid_4" = "C27007_014",
              "medicaid_5" = "C27007_017",
              "medicaid_6" = "C27007_020",
              "Total_Pop" = "B01001_001"
              
              ),
  year=2019, 
  geometry=TRUE) %>%
  group_by(GEOID) %>%
  summarize(snap_hh = estimate[variable=="snap_hh"],
            medicaid_pop =estimate[variable=="medicaid_1"] + 
                          estimate[variable=="medicaid_2"] +
                          estimate[variable=="medicaid_3"] +
                          estimate[variable=="medicaid_4"] +
                          estimate[variable=="medicaid_5"] +
                          estimate[variable=="medicaid_6"] ,
            total_pop = estimate[variable=="Total_Pop"])

total_nm_tracts <- cbind(nm_geo, nm_blocks)


```


The table below shows total population by LMI qualification method by utility area coverage. Note, these LMI groups are not mutually exclusive, rather are snap shots of the individual method's population. 

```{r echo=FALSE, message=FALSE, warning=FALSE}


temp <- total_nm_tracts %>% 
  st_point_on_surface() %>%
  st_make_valid() %>%
  st_join(temp_util %>% select(NAME)) %>%
  st_drop_geometry() %>%
  group_by(Name = NAME) %>%
  filter(!is.na(Name)) %>%
  summarize(`Pop under 80 AMI` = sum(AMI_80),
            `Medicaid` = sum(medicaid_pop),
            `SNAP HH` = sum(snap_hh),
            `Total Population` = sum(total_pop)) %>%
  arrange(desc(`Pop under 80 AMI`)) 

datatable(temp, caption = "New Mexico, Sources: ACS 2019 and HUD CHAS")%>%
  formatCurrency('Pop under 80 AMI',currency = "", interval = 3, mark = ",") %>%
  formatCurrency('Medicaid',currency = "", interval = 3, mark = ",") %>%
  formatCurrency('SNAP HH',currency = "", interval = 3, mark = ",") %>%
  formatCurrency('Total Population',currency = "", interval = 3, mark = ",") 





```


The map shows the census tracts loaded with the LMI qualification methods by utility zone coverage. 




```{r echo=FALSE, message=FALSE, warning=FALSE, fig.height=10, fig.width=8}

nm_df <- add_geo %>%
  filter(State_Name == "New Mexico") 

pal <- colorNumeric(
  palette = "Reds",
 # reverse=TRUE,
  domain = nm_df$AMI_80)

pal2 <- colorNumeric(
  palette = "Purples",
 # reverse=TRUE,
  domain = nm_df$AMI_80_Pct)

pal3 <- colorNumeric(
  palette = "Greens",
 # reverse=TRUE,
  domain = nm_blocks$snap_hh)

pal4 <- colorNumeric(
  palette = "Blues",
 # reverse=TRUE,
  domain = nm_blocks$medicaid_pop)


 



map <- leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data=temp_util,
              group="Utility Zones",
              stroke=TRUE,
              color="black",
              dashArray="3",
              fillOpacity=0,
              popup=paste("Utility Zone: ", temp_util$new_name)
  ) %>%
  
  addPolygons(
    data = nm_df,
    group="80% AMI",  # This should be consistent with the group name in the addLegend function
    stroke=FALSE,
    smoothFactor=0.2,
    fillOpacity=0.7,
    color=~pal(AMI_80),
    popup=paste("Tract: ", nm_df$geoid, "<br>", 
                "HHs at 80% AMI: ", nm_df$AMI_80)
  ) %>%

  addLegend("bottomleft",
            group="80% AMI",  # This should be consistent with the group name in the addPolygons function
            pal = pal,
            values = nm_df$AMI_80,
            title="Number of HHs at 80% AMI"
  ) %>%
  
  # addPolygons(
  #   data=nm_df,
  #   group="80% AMI Percent",  # This should be consistent with the group name in the addLegend function
  #   stroke=FALSE,
  #   smoothFactor=0.2,
  #   fillOpacity=0.7,
  #   color=~pal2(AMI_80_Pct),
  #   popup=paste("Tract: ", nm_df$geoid, "<br>", 
  #               "Percent of HHs at 80% AMI: ", nm_df$AMI_80_Pct)
  # ) %>%
  # 
  # addLegend("bottomleft",
  #           group="80% AMI Percent",  # This should be consistent with the group name in the addPolygons function
  #           pal = pal2,
  #           values = nm_df$AMI_80_Pct,
  #           title="Percent of HHs at 80% AMI"
  # ) %>%
  
  addPolygons(
    data=nm_blocks,
    group="SNAP",
    stroke=FALSE,
    smoothFactor=0.2,
    fillOpacity=0.7,
    color=~pal3(snap_hh),
    popup=paste("Tract: ", nm_blocks$GEOID, "<br>", 
                "Number of HHs Receiving SNAP: ", nm_blocks$snap_hh)
  ) %>%
  
  addLegend("bottomleft",
            group="SNAP",
            pal = pal3,
            values = nm_blocks$snap_hh,
            title="Number of HHs Receiving SNAP:"
  ) %>%
  
  addPolygons(
    data=nm_blocks,
    group="Medicaid",
    stroke=FALSE,
    smoothFactor=0.2,
    fillOpacity=0.7,
    color=~pal4(medicaid_pop),
    popup=paste("Tract: ", nm_blocks$GEOID, "<br>", 
                "Number of HHs Receiving Medicaid: ", nm_blocks$medicaid_pop)
  ) %>%
  
  addLegend("bottomleft",
            group="Medicaid",
            pal = pal4,
            values = nm_blocks$medicaid_pop,
            title="Number of HHs Receiving Medicaid:"
  ) %>%
   
  addLayersControl(
    overlayGroups=c( "80% AMI", "Utility Zones", "SNAP", "Medicaid"),  # Update the order for consistency
    options = layersControlOptions(collapsed = FALSE)
  )

map %>%
 hideGroup("SNAP") %>% hideGroup("80% AMI") %>% hideGroup("Medicaid")

```







### Low Income Housing

To estimate the total number of New Mexicans residing in low income housing, we first require a list of eligible properties. We take each affordable rental property listed on the [MFA Housing New Mexico](https://housingnm.org/find-housing/rentals/affordable) website. After geocoding each point, we have several options for determining the population concentration around each point. A common technique in transportation modeling is applying an isocrhone, or a travel time map. In our case, we want to see how many eligible population of SNAP, Medicaid and 80% AMI households are within a 15 and 30 minute driving radius around each point. 

```{r message=FALSE, warning=FALSE, include=FALSE}
# nm_data <- read_excel("data/nm/nm_public_housing.xlsx")
# 
# 
# 
# library(ggmap)
# 
# # Assuming your 'nm_data' dataframe has columns 'Address' and 'Address 2'
# # Create a new column to store the full address (combining Address and Address 2)
# nm_data$full_address <- paste(nm_data$Address, nm_data$`Address 2`, sep = ", ")
# 
# # Use geocode() to get latitude and longitude for each address
# geocoded_data <- geocode(nm_data$full_address)
# 
# # Add latitude and longitude columns to the original dataframe
# nm_data$Latitude <- geocoded_data$lat
# nm_data$Longitude <- geocoded_data$lon
# 
# nm_data <- nm_data %>%?
#   filter(!is.na(Longitude))
# 
# nm_data <- st_as_sf(nm_data, coords = c("Longitude", "Latitude"), crs = st_crs(nm_blocks))

# st_write(nm_data, "nm_public_housing.shp")




nm_public_housing <- st_read("data/nm/nm_public_housing.shp")

# nm_public_housing_isos <- nm_public_housing %>%
#   mb_isochrone(time = 30, profile = "driving", id_column = "Name",
#                access_token = "blahblahblah"

nm_public_housing_isos_15 <- st_read("isochrones/nm_public_housing_isos_15.shp") 
nm_public_housing_isos_15 <- st_transform(nm_public_housing_isos_15, st_crs(nm_public_housing))

nm_public_housing_isos_30 <- st_read("isochrones/nm_public_housing_isos_30.shp")
nm_public_housing_isos_30 <- st_transform(nm_public_housing_isos_30, st_crs(nm_public_housing))


```

```{r echo=FALSE, message=FALSE, warning=FALSE}

library(leaflet.extras)


nm_pub_in_util <- nm_public_housing %>%
  st_point_on_surface() %>%
  st_join(temp_util %>% select(util_name = NAME)) %>%
  filter(!is.na(util_name))


houses_in_utilies <- nm_pub_in_util$Name

iso_15 <- nm_public_housing_isos_15 %>%
  filter(id %in% houses_in_utilies)

iso_30 <- nm_public_housing_isos_30 %>%
  filter(id %in% houses_in_utilies)


map %>%
  # addMarkers(data=nm_public_housing,
  #                  group="Public Housing",
  #               #   color="black",
  #               #   radius=2,
  #                  popup=paste("Name: ", nm_public_housing$Name)) %>%
  addMarkers(data = nm_pub_in_util,
             group="Public Housing",
           #  color="red",
            popup=paste("Name: ", nm_pub_in_util$util_name)) %>%
  addPolygons(data =iso_15,
              group = "15 Minute Driving",
              fillOpacity = 0.2,
              color = "orange") %>%
    addPolygons(data =iso_30,
              group = "30 Minute Driving",
              fillOpacity = 0.2,
              color = "darkgreen") %>%

  addLayersControl(
    overlayGroups=c("80% AMI", "Utility Zones", "SNAP", "Medicaid", "Public Housing", "15 Minute Driving", "30 Minute Driving"),  # Update the order for consistency
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  hideGroup("80% AMI Percent") %>% hideGroup("SNAP") %>% hideGroup("80% AMI") %>% hideGroup("Medicaid") 


```





```{r message=FALSE, warning=FALSE, include=FALSE}



# Assuming 'snap' column is present in total_nm_tracts
# Check validity of isochrones
iso_15_valid <- st_is_valid(iso_15)


# Find indices of invalid isochrones
invalid_indices <- which(!iso_15_valid)


# Filter out invalid isochrones
valid_iso_15 <- iso_15[-invalid_indices, ]

total_nm_tracts$total_area_tract <- st_area(total_nm_tracts)


# Find the intersection of valid_iso_15 with total_nm_tracts
intersecting_tracts <- st_intersection(total_nm_tracts, valid_iso_15)

# Calculate the area of valid_iso_15 that covers each tract
intersecting_tracts$covered_area <- st_area(intersecting_tracts)

# Calculate the proportion of coverage for each tract
intersecting_tracts$proportion_coverage <- intersecting_tracts$covered_area / total_nm_tracts$total_area_tract

# If you want to consider the 'snap' column for calculating the proportion
# You can adjust the calculation based on your needs
intersecting_tracts$proportion_snap_coverage <- intersecting_tracts$proportion_coverage * intersecting_tracts$snap_hh
intersecting_tracts$proportion_medicaid_pop <- intersecting_tracts$proportion_coverage * intersecting_tracts$medicaid_pop
intersecting_tracts$proportion_80ami_coverage <- intersecting_tracts$proportion_coverage * intersecting_tracts$AMI_80
intersecting_tracts$proportion_total_pop <- intersecting_tracts$proportion_coverage * intersecting_tracts$total_pop


temp_15 <- intersecting_tracts %>%
  st_drop_geometry() %>%
  group_by(geoid) %>%
  summarize(total_snap = max(snap_hh), 
            total_medicaid = max(medicaid_pop),
            total_80ami = max(AMI_80),
            covered_area = sum(proportion_coverage),
            total_pop = max(total_pop)) %>%
  mutate(covered_prop = 
            case_when(
                as.numeric(covered_area) >= 100 ~ 1,
                TRUE ~ as.numeric(covered_area))
    
    
    ) %>%
  mutate(
    proportion_snap = covered_prop * total_snap/100,
    proportion_medicaid = covered_prop * total_medicaid/100,
    proportion_80ami = covered_prop * total_80ami/100,
    proportion_total_pop = covered_prop * total_pop/100,
    isochrone = "15 Minute"
  ) %>%
  group_by(isochrone) %>%
  summarize(SNAP = sum(proportion_snap),
            
            Medicaid = sum(proportion_medicaid),
            LMI = sum(proportion_80ami),
            Total_Pop = sum(proportion_total_pop))



temp_15





```



```{r message=FALSE, warning=FALSE, include=FALSE}


# Assuming 'snap' column is present in total_nm_tracts
# Check validity of isochrones
iso_30_valid <- st_is_valid(iso_30)


# Find indices of invalid isochrones
invalid_indices <- which(!iso_30_valid)


# Filter out invalid isochrones
valid_iso_30 <- iso_30[-invalid_indices, ]

total_nm_tracts$total_area_tract <- st_area(total_nm_tracts)


# Find the intersection of valid_iso_30 with total_nm_tracts
intersecting_tracts <- st_intersection(total_nm_tracts, iso_30)

# Calculate the area of valid_iso_30 that covers each tract
intersecting_tracts$covered_area <- st_area(intersecting_tracts)

# Calculate the proportion of coverage for each tract
intersecting_tracts$proportion_coverage <- intersecting_tracts$covered_area / total_nm_tracts$total_area_tract

# If you want to consider the 'snap' column for calculating the proportion
# You can adjust the calculation based on your needs
intersecting_tracts$proportion_snap_coverage <- intersecting_tracts$proportion_coverage * intersecting_tracts$snap_hh
intersecting_tracts$proportion_medicaid_pop <- intersecting_tracts$proportion_coverage * intersecting_tracts$medicaid_pop
intersecting_tracts$proportion_80ami_coverage <- intersecting_tracts$proportion_coverage * intersecting_tracts$AMI_80
intersecting_tracts$proportion_total_pop <- intersecting_tracts$proportion_coverage * intersecting_tracts$total_pop


temp_30 <- intersecting_tracts %>%
  st_drop_geometry() %>%
  group_by(geoid) %>%
  summarize(total_snap = max(snap_hh), 
            total_medicaid = max(medicaid_pop),
            total_80ami = max(AMI_80),
            covered_area = sum(proportion_coverage),
            total_pop = max(total_pop)) %>%
  mutate(covered_prop = 
            case_when(
                as.numeric(covered_area) >= 100 ~ 1,
                TRUE ~ as.numeric(covered_area))
    
    
    ) %>%
  mutate(
    proportion_snap = covered_prop * total_snap/100,
    proportion_medicaid = covered_prop * total_medicaid/100,
    proportion_80ami = covered_prop * total_80ami/100,
    proportion_total_pop = covered_prop * total_pop/100,
    isochrone = "30 Minute"
  ) %>%
  group_by(isochrone) %>%
  summarize(SNAP = sum(proportion_snap),
            
            Medicaid = sum(proportion_medicaid),
            LMI = sum(proportion_80ami),
            Total_Pop = sum(proportion_total_pop))



temp_30

temp <- rbind(temp_15, temp_30)

```





```{r echo=FALSE, message=FALSE, warning=FALSE}

datatable(temp, caption = "New Mexico Distance from Public Housing and Selected Characteristics")%>%
  formatCurrency('LMI',currency = "", interval = 3, mark = ",") %>%
  formatCurrency('Medicaid',currency = "", interval = 3, mark = ",") %>%
  formatCurrency('SNAP',currency = "", interval = 3, mark = ",")  %>%
  formatCurrency('Total_Pop', currency="", interval = 3, mark = ",")



```



# New York (VDER ICSA)


```{r message=FALSE, warning=FALSE, include=FALSE}

#  * NYSERDA [Supported Solar Projects](https://www.nyserda.ny.gov/All-Programs/NY-Sun/Solar-Data-Maps/NYSERDA-Supported-Solar-Projects)





ny_geo <- add_geo %>%
  filter(State_Name=="New York")

temp_util <- st_read("data/NY/ny_utils.shp") %>%
  filter(grepl("NGRID|NYSEG|CHGE|RGE|ORU", comp_short))


dac_bgs <- st_read("data/NY/Interim Disadvantaged Communities (DAC)_ 2020/geo_export_ae5e9c30-45bc-4888-87dd-681a41d761d8.shp")

lift_df <- read.csv("data/groundswell_lift/cs-projects-2023-08-18.csv") 

lift_df <- separate(lift_df, GeoCode, into = c("long", "lat"), sep = ",")

lift_df <- st_as_sf(lift_df, coords = c("long", "lat"), crs = st_crs(nm_blocks))


ny_tracts <- get_acs(
  geography="tract", 
  state="NY",
  variables=c("Total_Pop" = "B01001_001","snap_hh" = "B22001_002","snap_pop" = "B19058_002"
              
              ),
  year=2019, 
  geometry=TRUE) %>%
  group_by(GEOID) %>%
  summarize(total_pop = estimate[variable=="Total_Pop"],
            snap_hh = estimate[variable=="snap_hh"],
            snap_pop = estimate[variable=="snap_pop"])




# ny_bgs <- get_acs(
#   geography="block group", 
#   state="NY",
#   variables=c("Total_Pop" = "B01001_001"),
#   year=2019, 
#   geometry=TRUE) 
# 
# lmi_data <- read_excel("data/NY/ny-lowmod-blockgroup.xls")




total_ny_tracts <- cbind(ny_geo, ny_tracts)




```



## Geoqualification

Residence in a DAC or EmPower pre-screened area. 

  * [Pre-screened areas](https://www.nyserda.ny.gov/ny/ahp-empower/geo-eligible-income-tool)
  * DAC interim [disadvantaged areas](https://data.ny.gov/Energy-Environment/Interim-Disadvantaged-Communities-DAC-2020/t6wd-tdrv)


We consider the following five utility zones in New York:

  * National Grid
  * NYSEG
  * Central Hudson
  * Rochester Gas & Electric
  * Orange & Rockland


### Pre-screened areas

**to-do**: note, recreating eligible block groups is not available. 


### DAC BGs

4,145 census block groups are tagged as disadvantaged communities defined by New York State. 


```{r echo=FALSE, message=FALSE, warning=FALSE}


temp_util <- st_zm(temp_util, drop = TRUE)


pal5 <- colorFactor(
  palette="viridis",
  domain=temp_util$comp_full
)
# Create the leaflet map
leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data = temp_util,
              group = "Utility Zones",
              stroke = TRUE,
              color = ~pal5(temp_util$comp_full),
              dashArray = "3",
              fillOpacity = 0.5,
              popup = paste("Utility Zone: ", temp_util$comp_full)) %>%


  addLegend(position = "bottomright",
            pal = pal5,
            group = "Utility Zones",
            values = temp_util$comp_full,
            title = "Solstice NY Utilities") %>%
  addPolygons(data = dac_bgs,
              group="DAC",
              popup = paste("Name: ", dac_bgs$geoid, "<br>",
                           "Pop 2018: ", dac_bgs$pop_2018)) %>%
  addLayersControl(
    overlayGroups=c( "Utility Zones", "DAC"),  # Update the order for consistency
    options = layersControlOptions(collapsed = FALSE)
  )

```


```{r echo=FALSE, message=FALSE, warning=FALSE}

library(janitor)
dac_bgs <- st_transform(dac_bgs, st_crs(total_nm_tracts)) %>% st_make_valid()

tot_ny_pop <- sum(total_ny_tracts$total_pop)

temp <- dac_bgs %>% 
  st_point_on_surface() %>%
  st_make_valid() %>%
  st_join(temp_util %>% select(comp_full)) %>%
  st_drop_geometry() %>%
  group_by(Name = comp_full) %>%
  filter(!is.na(Name)) %>%
  summarize(Population = sum(pop_2018)
            ) %>%
  arrange(desc(Population)) %>%
  adorn_totals("row") %>%
  mutate(Percentage = Population / tot_ny_pop )

  

datatable(temp, caption = "Interim Disadvantaged Communities (DAC) Population by Utiliy Zone")%>%
  formatCurrency('Population',currency = "", interval = 3, mark = ",") %>%
  formatPercentage('Percentage', digits = 2)





```



## LMI Qualifications


New York LMI Qualification methods are detailed in the [policy matrix](https://coda.io/d/Solstice-Policy_dBUL-zOSfnb/Program-Matrix_suVJB#Program-Matrix_tuLIr/r11&view=full), but in summary include:

  * **LMI - 80% of AMI**
  * Award letters for EmPower, HEAP, SNAP, TANF, SSSI; HEAP or other assistance on utility bill
  
  




The table below shows total population by LMI qualification method by utility area coverage. Note, these LMI groups are not mutually exclusive, rather are snap shots of the individual method's population. 

```{r echo=FALSE, message=FALSE, warning=FALSE}


temp <- total_ny_tracts %>% 
  st_point_on_surface() %>%
  st_make_valid() %>%
  st_join(temp_util %>% select(comp_short)) %>%
  st_drop_geometry() %>%
  group_by(Name = comp_short) %>%
  filter(!is.na(Name)) %>%
  summarize(`Pop under 80 AMI` = sum(AMI_80),
             `SNAP HH` = sum(snap_hh),
            `Total Population` = sum(total_pop)) %>%
  arrange(desc(`Pop under 80 AMI`)) 


temp
# datatable(temp, caption = "New York, Sources: ACS 2019 and HUD CHAS")%>%
#   formatCurrency('Pop under 80 AMI',currency = "", interval = 3, mark = ",") %>%
#   formatCurrency('SNAP HH',currency = "", interval = 3, mark = ",") %>%
#   formatCurrency('Total Population',currency = "", interval = 3, mark = ",") 





```

The map shows the census tracts loaded with the LMI qualification methods by utility zone coverage. 




```{r echo=FALSE, fig.height=10, fig.width=8, message=FALSE, warning=FALSE}



pal <- colorNumeric(
  palette = "viridis",
 # reverse=TRUE,
  domain = ny_geo$AMI_80)

pal2 <- colorNumeric(
  palette = "Purples",
 # reverse=TRUE,
  domain = ny_geo$AMI_80_Pct)

pal3 <- colorNumeric(
  palette = "viridis",
 # reverse=TRUE,
  domain = total_ny_tracts$snap_hh)

library(tidyr)



ny_lift <- lift_df %>%
  filter(State=="New York")
 



map <- leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data=temp_util,
              group="Utility Zones",
              stroke=TRUE,
              color="black",
              dashArray="3",
              fillOpacity=0,
              popup=paste("Utility Zone: ", temp_util$comp_short)
  ) %>%
  
  addPolygons(
    data = ny_geo,
    group="80% AMI",  # This should be consistent with the group name in the addLegend function
    stroke=FALSE,
    smoothFactor=0.2,
    fillOpacity=0.85,
    color=~pal(AMI_80),
    popup=paste("Tract: ", ny_geo$geoid, "<br>", 
                "HHs at 80% AMI: ", ny_geo$AMI_80)
  ) %>%

  addLegend("bottomleft",
            group="80% AMI",  # This should be consistent with the group name in the addPolygons function
            pal = pal,
            values = ny_geo$AMI_80,
            title="Number of HHs at 80% AMI"
  ) %>%
  
  # addPolygons(
  #   data=nm_df,
  #   group="80% AMI Percent",  # This should be consistent with the group name in the addLegend function
  #   stroke=FALSE,
  #   smoothFactor=0.2,
  #   fillOpacity=0.7,
  #   color=~pal2(AMI_80_Pct),
  #   popup=paste("Tract: ", nm_df$geoid, "<br>", 
  #               "Percent of HHs at 80% AMI: ", nm_df$AMI_80_Pct)
  # ) %>%
  # 
  # addLegend("bottomleft",
  #           group="80% AMI Percent",  # This should be consistent with the group name in the addPolygons function
  #           pal = pal2,
  #           values = nm_df$AMI_80_Pct,
  #           title="Percent of HHs at 80% AMI"
  # ) %>%
  
  addPolygons(
    data=total_ny_tracts,
    group="SNAP",
    stroke=FALSE,
    smoothFactor=0.2,
    fillOpacity=0.7,
    color=~pal3(snap_hh),
    popup=paste("Tract: ", total_ny_tracts$GEOID, "<br>",
                "Number of HHs Receiving SNAP: ", total_ny_tracts$snap_hh)
  ) %>%

  addLegend("bottomleft",
            group="SNAP",
            pal = pal3,
            values = total_ny_tracts$snap_hh,
            title="Number of HHs Receiving SNAP:"
  ) %>%
  



  addLayersControl(
    overlayGroups=c( "80% AMI", "Utility Zones", "SNAP"),  # Update the order for consistency
    options = layersControlOptions(collapsed = FALSE)
  )

map %>%
 hideGroup("SNAP") %>% hideGroup("80% AMI")

```




### LIFT Solar



Groundswell manages the LIFT solar dataset of over 450 LMI community solar projects across the country. Project capacity (KW AC) and number of potential LMI customers per project is shown from this dataset. Note, there are no LIFT projects in New Mexico. 


```{r echo=FALSE, fig.height=10, fig.width=8, message=FALSE, warning=FALSE}

ny_geo <- add_geo %>%
  filter(State_Name == "New York") 

ny_lift <- lift_df %>%
  filter(State == "New York")


pal_potLMI <- colorNumeric(
  palette = "viridis",
 # reverse=TRUE,
  domain = ny_lift$Potential...LMI.Subscribers)

pal_cap <- colorNumeric(
  palette = "viridis",
 # reverse=TRUE,
  domain = ny_lift$Project.Capacity.KW.AC)



pal <- colorNumeric(
  palette = "viridis",
 # reverse=TRUE,
  domain = ny_geo$AMI_80)

pal2 <- colorNumeric(
  palette = "Purples",
 # reverse=TRUE,
  domain = ny_geo$AMI_80_Pct)

pal3 <- colorNumeric(
  palette = "viridis",
 # reverse=TRUE,
  domain = total_ny_tracts$snap_hh)

library(tidyr)



ny_lift <- lift_df %>%
  filter(State=="New York")
 



map <- leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data=temp_util,
              group="Utility Zones",
              stroke=TRUE,
              color="black",
              dashArray="3",
              fillOpacity=0,
              popup=paste("Utility Zone: ", temp_util$comp_short)
  ) %>%
  
  addPolygons(
    data = ny_geo,
    group="80% AMI",  # This should be consistent with the group name in the addLegend function
    stroke=FALSE,
    smoothFactor=0.2,
    fillOpacity=0.85,
    color=~pal(AMI_80),
    popup=paste("Tract: ", ny_geo$geoid, "<br>", 
                "HHs at 80% AMI: ", ny_geo$AMI_80)
  ) %>%

  addLegend("bottomleft",
            group="80% AMI",  # This should be consistent with the group name in the addPolygons function
            pal = pal,
            values = ny_geo$AMI_80,
            title="Number of HHs at 80% AMI"
  ) %>%
  
  # addPolygons(
  #   data=nm_df,
  #   group="80% AMI Percent",  # This should be consistent with the group name in the addLegend function
  #   stroke=FALSE,
  #   smoothFactor=0.2,
  #   fillOpacity=0.7,
  #   color=~pal2(AMI_80_Pct),
  #   popup=paste("Tract: ", nm_df$geoid, "<br>", 
  #               "Percent of HHs at 80% AMI: ", nm_df$AMI_80_Pct)
  # ) %>%
  # 
  # addLegend("bottomleft",
  #           group="80% AMI Percent",  # This should be consistent with the group name in the addPolygons function
  #           pal = pal2,
  #           values = nm_df$AMI_80_Pct,
  #           title="Percent of HHs at 80% AMI"
  # ) %>%
  
  addPolygons(
    data=total_ny_tracts,
    group="SNAP",
    stroke=FALSE,
    smoothFactor=0.2,
    fillOpacity=0.7,
    color=~pal3(snap_hh),
    popup=paste("Tract: ", total_ny_tracts$GEOID, "<br>",
                "Number of HHs Receiving SNAP: ", total_ny_tracts$snap_hh)
  ) %>%

  addLegend("bottomleft",
            group="SNAP",
            pal = pal3,
            values = total_ny_tracts$snap_hh,
            title="Number of HHs Receiving SNAP:"
  ) %>%
  
    addCircleMarkers(data = ny_lift,
                   group="Potential LMI Subscribers",
                   popup = ~paste("Program Name: ", Program.Name, "<br>",
                                  "Developer/Owner: ", Project.Developer.or.Owner, "<br>", 
                                  "Project Capacity: ", Project.Capacity.KW.AC, "<br>",
                                  "LMI Savings: ", LMI.Customer.Savings.., "<br>",
                                  "Potential LMI Subscribers: ", Potential...LMI.Subscribers),
                   radius = ny_lift$Potential...LMI.Subscribers/15, 
                   color = ~pal_potLMI(Potential...LMI.Subscribers)) %>%
  addLegend("bottomright",
            group="Potential LMI Subscribers",  # This should be consistent with the group name in the addPolygons function
            pal = pal_potLMI,
            values = ny_lift$Potential...LMI.Subscribers,
            title="Potential LMI Subscribers") %>%

    ## Project Capacity ## 
  
  addCircleMarkers(data = ny_lift,
                   group="Project Capacity",
                   popup = ~paste("Program Name: ", Program.Name, "<br>",
                                  "Developer/Owner: ", Project.Developer.or.Owner, "<br>", 
                                  "Project Capacity: ", Project.Capacity.KW.AC, "<br>",
                                  "LMI Savings: ", LMI.Customer.Savings.., "<br>",
                                  "Potential LMI Subscribers: ", Potential...LMI.Subscribers),
                   radius = ny_lift$Project.Capacity.KW.AC/100, 
                   color = ~pal_cap(Project.Capacity.KW.AC)) %>%
  addLegend("topleft",
             group="Project Capacity",  # This should be consistent with the group name in the addPolygons function
            pal = pal_cap,
            values = ny_lift$Project.Capacity.KW.AC,
            title="Project Capacity") %>%


  addLayersControl(
    overlayGroups=c( "80% AMI", "Utility Zones", "SNAP","Potential LMI Subscribers", "Project Capacity"),  # Update the order for consistency
    options = layersControlOptions(collapsed = FALSE)
  )

map %>%
 hideGroup("SNAP") %>% hideGroup("80% AMI") %>% hideGroup("Project Capacity")

```






# California

**to-do** 

1. add the CCA terriorties + penetration 
2. add CS saturation layer - how much current CS is in the market currently? 
3. add in the EIA number of households 












```{r message=FALSE, warning=FALSE, include=FALSE}
chas_df <- load_chas() %>%
    mutate(State_Name = case_when(
    state == 17 ~ "Illinois",
    state == 25 ~ "Massachusetts",  
    state == 27 ~ "Minnesota",  
    state == 34 ~ "New Jersey",
    state == 35 ~ "New Mexico",  
    state == 36 ~ "New York",
    state == 06 ~ "California",
    TRUE ~ "Other"
  ))



add_geo <- merge(chas_df, get_tracts) 

add_geo <- st_as_sf(add_geo)

add_geo <- add_geo %>%
  filter(State_Name=="California")

ca_tracts <- get_acs(
  geography="tract", 
  state="CA",
  variables=c("Total_Pop" = "B01001_001"),
  year=2019, 
  geometry=TRUE) 

ca_tracts$Tract <- as.double(ca_tracts$GEOID)

# utility download

temp_util <- st_read("data/CA/utils/Electric_Load_Serving_Entities_(IOU_%26_POU).shp")
temp_util <- st_transform(temp_util, crs = st_crs(ca_tracts))
temp_util <- st_zm(temp_util, drop = TRUE)




# CalEnviroScreen Data Download



#%>%
 # filter(CIscoreP >= 75) %>%
 # st_drop_geometry()




temp <- temp_util %>%
  select(OBJECTID, geometry)

env_df <- st_read("/Users/jacobford/Downloads/calenviroscreen40shpf2021shp/CES4 Final Shapefile.shp") 

env_df <- st_transform(env_df, crs = st_crs(ca_tracts))


ca_geo_qual <- st_read("data/CA/Low-income_or_Disadvantaged_Communities_Designated_by_California/Low-income_or_Disadvantaged_Communities_Designated_by_California.shp")

ca_geo_qual <- st_transform(ca_geo_qual, crs = st_crs(ca_tracts))

```

## Geoqualification

There are three main methods to geoqualify households in California:


  * Underserved community - low-income community under Health and Safety Code Sec. 39713
  * CalEnviroScreen disadvantaged community top quartile (ClscoreP)
  * California Native American tribe Public Resources Code Sec. 21073

The [California Energy Commission](https://cecgis-caenergy.opendata.arcgis.com/datasets/CAEnergy::low-income-or-disadvantaged-communities-designated-by-california/explore?location=37.177590%2C-119.274072%2C7.63) publishes the state specific low-income or disadvantaged communities. Census tracts with median household incomes at or below 80 percent of the statewide median income or with median household incomes at or below the threshold designated as low income by the Department of Housing and Community Developmentâ€™s list of state income limits adopted under Healthy and Safety Code section 50093 and/or Census tracts receiving the highest 25 percent of overall scores in CalEnviroScreen 4.0 or Census tracts lacking overall scores in CalEnviroScreen 4.0 due to data gaps, but receiving the highest 5 percent of CalEnviroScreen 4.0 cumulative population burden scores or Census tracts identified in the 2017 DAC designation as disadvantaged, regardless of their scores in CalEnviroScreen 4.0 or Lands under the control of federally recognized Tribes. 


## California Maps {.tabset}


### IOU-POU

California electric utility zones are shown below, broken out by IOU and POU status. 


```{r echo=FALSE, message=FALSE, warning=FALSE}
pal5 <- colorFactor(
  palette="viridis",
  domain=temp_util$Type
)
# Create the leaflet map
leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data = temp_util,
              group = "Utility Zones",
              stroke = FALSE,
              color = ~pal5(temp_util$Type),
              dashArray = "3",
              fillOpacity = 0.5,
              popup = paste("Utility Zone: ", temp_util$Acronym, "<br>",
                            "Utility Name: ", temp_util$Utility)) %>%


  addLegend(position = "bottomright",
            pal = pal5,
            group = "Utility Zones",
            values = temp_util$Type,
            title = "California Utilities") 
```


### Utilities

```{r echo=FALSE, message=FALSE, warning=FALSE}
pal5 <- colorFactor(
  palette="viridis",
  domain=temp_util$Acronym
)
# Create the leaflet map
leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data = temp_util,
              group = "Utility Zones",
              stroke = FALSE,
              color = ~pal5(temp_util$Acronym),
              dashArray = "3",
              fillOpacity = 0.5,
              popup = paste("Utility Zone: ", temp_util$Acronym, "<br>",
                            "Utility Name: ", temp_util$Utility)) %>%


  addLegend(position = "bottomright",
            pal = pal5,
            group = "Utility Zones",
            values = temp_util$Acronym,
            title = "California Utilities") 
```




```{r message=FALSE, warning=FALSE, include=FALSE}
temp <- ca_tracts %>%
  st_drop_geometry()



temp <- merge(temp, ca_geo_qual, by = c("GEOID"))

temp <- st_as_sf(temp)

temp$Population <- temp$estimate

```



```{r echo=FALSE, message=FALSE, warning=FALSE}

temp_table <- temp %>% 
  st_drop_geometry() %>%
  mutate(var = 1) %>%
  group_by(var) %>%
  summarize(Population = sum(Population)) %>%
  select(`Population Geoqualified` = Population ) %>%
  mutate(`Population Total` = sum(ca_tracts$estimate))


datatable(temp_table, caption = "California Geoqualified Population") %>%
    formatCurrency('Population Geoqualified',currency = "", interval = 3, mark = ",") %>%
    formatCurrency('Population Total',currency = "", interval = 3, mark = ",")


```



We'll quantify how many people are within these geoqualified zone, then break it down by utility zone. 


```{r echo=FALSE, message=FALSE, warning=FALSE}



tot_ca_pop <- sum(ca_tracts$estimate)

iou_utils <- temp_util %>%
  filter(Type=="IOU") %>%
  st_make_valid()


temp_table <- temp %>%
  st_point_on_surface() %>%
  st_make_valid() %>%
  st_join(iou_utils %>% select(Utility=Acronym)) %>%
  st_drop_geometry() %>%
  group_by(Utility) %>%
  summarize(Population = sum(Population)) %>%
  mutate(Percentage = Population/tot_ca_pop) %>%
  adorn_totals("row")

# 
# temp <- ca_tracts %>% 
#   st_point_on_surface() %>%
#   st_make_valid() %>%
#   st_join(ca_geo_qual %>% select(GEOID)) %>%
#   st_drop_geometry() %>%
#   filter(!is.na(GEOID.y)) %>%
#   mutate(var = 1) %>%
#   group_by(var) %>%
# 
#   summarize(Population = sum(estimate)
#             ) %>%
#   arrange(desc(Population)) %>%
#   adorn_totals("row") %>%
#   mutate(Percentage = Population / tot_ca_pop )

  

datatable(temp_table, caption = "California Geoqualified Population by Utiliy Zone")%>%
  formatCurrency('Population',currency = "", interval = 3, mark = ",") %>%
  formatPercentage('Percentage', digits = 2)





```

## LMI Qualifications

  * CARE Program
  * FERA Program
  * CalFresh Program
  * SNAP




### LIFT Solar





```{r echo=FALSE, fig.height=10, fig.width=8, message=FALSE, warning=FALSE}

temp_df <- add_geo %>%
  filter(State_Name == "California") 

temp_lift <- lift_df %>%
  filter(State == "California")


pal_potLMI <- colorNumeric(
  palette = "viridis",
 # reverse=TRUE,
  domain = temp_lift$Potential...LMI.Subscribers)

pal_cap <- colorNumeric(
  palette = "viridis",
 # reverse=TRUE,
  domain = temp_lift$Project.Capacity.KW.AC)



pal <- colorNumeric(
  palette = "viridis",
 # reverse=TRUE,
  domain = temp_df$AMI_80)

pal2 <- colorNumeric(
  palette = "Purples",
 # reverse=TRUE,
  domain = temp_df$AMI_80_Pct)

pal3 <- colorNumeric(
  palette = "viridis",
 # reverse=TRUE,
  domain = total_ny_tracts$snap_hh)

library(tidyr)



temp_lift <- lift_df %>%
  filter(State=="New York")
 



map <- leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data=temp_util,
              group="Utility Zones",
              stroke=TRUE,
              color="black",
              dashArray="3",
              fillOpacity=0,
              popup=paste("Utility Zone: ", temp_util$comp_short)
  ) %>%
  
  addPolygons(
    data = temp_df,
    group="80% AMI",  # This should be consistent with the group name in the addLegend function
    stroke=FALSE,
    smoothFactor=0.2,
    fillOpacity=0.85,
    color=~pal(AMI_80),
    popup=paste("Tract: ", temp_df$geoid, "<br>", 
                "HHs at 80% AMI: ", temp_df$AMI_80)
  ) %>%

  addLegend("bottomleft",
            group="80% AMI",  # This should be consistent with the group name in the addPolygons function
            pal = pal,
            values = temp_df$AMI_80,
            title="Number of HHs at 80% AMI"
  ) %>%
  
  # addPolygons(
  #   data=nm_df,
  #   group="80% AMI Percent",  # This should be consistent with the group name in the addLegend function
  #   stroke=FALSE,
  #   smoothFactor=0.2,
  #   fillOpacity=0.7,
  #   color=~pal2(AMI_80_Pct),
  #   popup=paste("Tract: ", nm_df$geoid, "<br>", 
  #               "Percent of HHs at 80% AMI: ", nm_df$AMI_80_Pct)
  # ) %>%
  # 
  # addLegend("bottomleft",
  #           group="80% AMI Percent",  # This should be consistent with the group name in the addPolygons function
  #           pal = pal2,
  #           values = nm_df$AMI_80_Pct,
  #           title="Percent of HHs at 80% AMI"
  # ) %>%
  
  addPolygons(
    data=total_ny_tracts,
    group="SNAP",
    stroke=FALSE,
    smoothFactor=0.2,
    fillOpacity=0.7,
    color=~pal3(snap_hh),
    popup=paste("Tract: ", total_ny_tracts$GEOID, "<br>",
                "Number of HHs Receiving SNAP: ", total_ny_tracts$snap_hh)
  ) %>%

  addLegend("bottomleft",
            group="SNAP",
            pal = pal3,
            values = total_ny_tracts$snap_hh,
            title="Number of HHs Receiving SNAP:"
  ) %>%
  
    addCircleMarkers(data = temp_lift,
                   group="Potential LMI Subscribers",
                   popup = ~paste("Program Name: ", Program.Name, "<br>",
                                  "Developer/Owner: ", Project.Developer.or.Owner, "<br>", 
                                  "Project Capacity: ", Project.Capacity.KW.AC, "<br>",
                                  "LMI Savings: ", LMI.Customer.Savings.., "<br>",
                                  "Potential LMI Subscribers: ", Potential...LMI.Subscribers),
                   radius = temp_lift$Potential...LMI.Subscribers/15, 
                   color = ~pal_potLMI(Potential...LMI.Subscribers)) %>%
  addLegend("bottomright",
            group="Potential LMI Subscribers",  # This should be consistent with the group name in the addPolygons function
            pal = pal_potLMI,
            values = temp_lift$Potential...LMI.Subscribers,
            title="Potential LMI Subscribers") %>%

    ## Project Capacity ## 
  
  addCircleMarkers(data = temp_lift,
                   group="Project Capacity",
                   popup = ~paste("Program Name: ", Program.Name, "<br>",
                                  "Developer/Owner: ", Project.Developer.or.Owner, "<br>", 
                                  "Project Capacity: ", Project.Capacity.KW.AC, "<br>",
                                  "LMI Savings: ", LMI.Customer.Savings.., "<br>",
                                  "Potential LMI Subscribers: ", Potential...LMI.Subscribers),
                   radius = temp_lift$Project.Capacity.KW.AC/100, 
                   color = ~pal_cap(Project.Capacity.KW.AC)) %>%
  addLegend("topleft",
             group="Project Capacity",  # This should be consistent with the group name in the addPolygons function
            pal = pal_cap,
            values = temp_lift$Project.Capacity.KW.AC,
            title="Project Capacity") %>%


  addLayersControl(
    overlayGroups=c( "80% AMI", "Utility Zones", "SNAP","Potential LMI Subscribers", "Project Capacity"),  # Update the order for consistency
    options = layersControlOptions(collapsed = FALSE)
  )

map %>%
 hideGroup("SNAP") %>% hideGroup("80% AMI") %>% hideGroup("Project Capacity")

```










# Illinois




```{r message=FALSE, warning=FALSE, include=FALSE}



temp_util <- hifld_df %>%
  filter(ID %in% c(56697, 4110,12341)) %>%
  mutate(new_name = case_when(
    ID == 56697 ~ "Ameren",
    ID == 4110 ~ "ComEd",
    ID == 12341 ~ "MidAmerican"
  ))

get_tracts <- get_acs(
  geography="tract", 
  state=state_list,
  variables=c("total_pop" = "B01001_001"),
  year=2019, 
  geometry=TRUE) %>%
  mutate(total_pop = estimate) %>%
  select(geoid=GEOID, geometry, total_pop)


```



## Geoqualification





```{r message=FALSE, warning=FALSE, include=FALSE}
chas_df <- load_chas() %>%
    mutate(State_Name = case_when(
    state == 17 ~ "Illinois",
    state == 25 ~ "Massachusetts",  
    state == 27 ~ "Minnesota",  
    state == 34 ~ "New Jersey",
    state == 35 ~ "New Mexico",  
    state == 36 ~ "New York",
    state == 06 ~ "California",
    TRUE ~ "Other"
  ))

il_counties <- get_acs(geography="county",
                       variables = c(totapop = "B01003_001"), 
              state = "IL", 
              year = 2021,
              geometry = TRUE)



add_geo <- merge(chas_df, get_tracts) 

add_geo <- st_as_sf(add_geo)

il_geo <- add_geo %>%
  filter(State_Name=="Illinois")

temp_util <- st_transform(temp_util, st_crs(il_geo)) %>%
  st_make_valid()
```

## LMI Qualifications


* 80% AMI

```{r echo=FALSE, message=FALSE, warning=FALSE}

pal5 <- colorFactor(
  palette="viridis",
  domain=temp_util$new_name
)

il_counties <- il_counties %>%
  filter(GEOID == 17073 | GEOID == 17131)

leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data=temp_util,
              group="Utility Zones",
              stroke=TRUE,
              color=~pal5(temp_util$new_name),
              dashArray="3",
              fillOpacity=0.25,
              popup=paste("Utility Zone: ", temp_util$new_name)) %>%
  addLegend(position="bottomright",
            pal=pal5,
            values=temp_util$new_name,
            title="Solstice IL Utilities") %>%
  addPolygons(data=il_counties, 
              stroke=TRUE,
              color="black",
              dashArray="3",
              group="Counties",
              fillOpacity=0,
              popup=paste("Utility Zone: ", il_counties$NAME)) %>%
  # addPolygons(data = il_tracts,
  #             color = "red",
  #             fillOpacity = .5,
  #             popup=paste("GEOID: ", il_tracts$geoid)) %>%
  
  
  addLayersControl(
    overlayGroups=c( "Counties", "Utility Zones"),  # Update the order for consistency
    options = layersControlOptions(collapsed = FALSE)
  )
```




### Total Pop/HH Coverage



```{r message=FALSE, warning=FALSE, include=FALSE}
# Specify the variables you're interested in
vars <- c("B01003_001",# total population
          "B11001_001", # total households
          "B25003_001" # total occupied households
          ) 

# Retrieve population data for Mercer County, Illinois
mercer_data <- get_decennial(
  geography = "block",
  variables = c("total_pop" = "P1_001N",
                "total_hh" = "H1_001N",
                "total_occ_hh" = "H1_002N"),
  state = "IL",
  county = c("131"),
  year = 2020,
  geometry = TRUE
) %>%
  group_by(GEOID) %>%
  summarize(
    total_pop = value[variable == "total_pop"],
    total_hh = value[variable == "total_hh"],
    total_occ_hh = value[variable == "total_occ_hh"]
  )
# Retrieve population data for Henry County, Illinois

henry_data <- get_decennial(
  geography = "block",
  variables = c("total_pop" = "P1_001N",
                "total_hh" = "H1_001N",
                "total_occ_hh" = "H1_002N"),
  state = "IL",
  county = c("073"),
  year = 2020,
  geometry = TRUE
) %>%
  group_by(GEOID) %>%
  summarize(
    total_pop = value[variable == "total_pop"],
    total_hh = value[variable == "total_hh"],
    total_occ_hh = value[variable == "total_occ_hh"]
  )


```





```{r echo=FALSE, message=FALSE, warning=FALSE}
## Mercer Demographic Table

total_hh <- sum(mercer_data$total_hh)

temp <- mercer_data %>% 
  st_point_on_surface() %>%
  st_make_valid() %>%
  st_join(temp_util %>% select(NAME)) %>%
  st_drop_geometry() %>%
  group_by(Name = NAME) %>%
  filter(!is.na(Name)) %>%
  summarize(`Total HH` = sum(total_hh),
            `Total Occupied HH` = sum(total_occ_hh),
            `Total Population` = sum(total_pop)) %>%
  adorn_totals("row") %>%
  mutate('Total HH Pct' = `Total HH` / sum(mercer_data$total_hh),
         'Total HH Occupied Pct' = `Total Occupied HH` / sum(mercer_data$total_occ_hh) ,
         'Total Population Pct' = `Total Population` / sum(mercer_data$total_pop) )

datatable(temp, caption = "Mercer County, Sources: ACS 2019 and HUD CHAS")%>%
  formatCurrency('Total HH', currency = "", mark = ",", interval = 3, digits = 0) %>%
  formatCurrency('Total Occupied HH', currency = "", mark = ",", interval = 3, digits = 0) %>%
  formatCurrency('Total Population', currency = "", mark = ",", interval = 3, digits = 0) %>%
  formatPercentage('Total HH Pct',digits=2, interval = 3) %>%
  formatPercentage('Total HH Occupied Pct',digits=2, interval = 3) %>%
  formatPercentage('Total Population Pct',digits=2, interval = 3)




```




# Delaware

Delaware's [Community Energy Facilities](https://depsc.delaware.gov/2022/02/01/community-energy-facilities-webpage/) program has an LMI carveout of 15%. LMI customers are defined via geoqualificaiton and income verification/self-attestation. 

## Geoqualification

Customers are defined as geoqualified if they reside in a census block "where the median household income is at or below 200% of the U.S. Federal Poverty Guidelines or 60% of the state median household income published by the United States Census Bureau, whichever is greater". 

Note, census blocks do not contain income information. This data is only available at the census block group or tract level. To approximate the population geoqualified in Delaware, we use a modified definition. Using 2021 5-Year ACS data, we define a geoqualified block group as one where at least 50% of the population is at or below 200% of the [Federal Poverty Line](https://data.census.gov/table?q=c17002&g=040XX00US10,10$1400000,10$1500000). 
    
There are 706 block groups in Delaware, a total of 77 are tagged as geoqualified using this method. The below map shows our tagged census block groups: 



```{r message=FALSE, warning=FALSE, include=FALSE}



get_blocks <- get_acs(
  geography="block group", 
  state="DE",
  variables=c("Total" = "C17002_001",
              "group1" = "C17002_002",
              "group2" = "C17002_003",
              "group3" = "C17002_004",
              "group4" = "C17002_005",
              "group5" = "C17002_006",
              "group6" = "C17002_007",
              "group7" = "C17002_008",
              "snap_hh" = "B19123_002",
              "snap_pop" = "B19058_002"),
  year=2021, 
  geometry=TRUE)  


####

get_blocks <- get_blocks %>%
  group_by(GEOID, geometry)  %>%
  summarize(total_pop = estimate[variable=="Total"],
            total_under_200FPL =
                          estimate[variable=="group1"] + 
                          estimate[variable=="group2"] +
                          estimate[variable=="group3"] +
                          estimate[variable=="group4"] +
                          estimate[variable=="group5"] +
                          estimate[variable=="group6"] ,
            snap_hh = estimate[variable=="snap_hh"],
            snap_pop = estimate[variable== "snap_pop"]) %>%
  mutate(pct_under_200FPL = total_under_200FPL / total_pop) %>%
  mutate(geo_tag = case_when(
    pct_under_200FPL >= 0.5 ~ 1,
    TRUE ~ 0
  ))

```

```{r echo=FALSE, message=FALSE, warning=FALSE}
pal5 <- colorFactor(
  palette=c("lightgrey", "darkgreen"),
  domain=get_blocks$geo_tag
)


leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data=get_blocks,
              group="Block Groups",
             # stroke = TRUE,
              color = ~pal5(get_blocks$geo_tag),
              fillOpacity=0.75,
              popup=paste("Census Block Group: ", get_blocks$GEOID, "<br>",
                          "Percent under 200% FPL: ", get_blocks$pct_under_200FPL, "<br>",
                          "Number under 200% FPL: ", get_blocks$total_under_200FPL)) %>%
  addLegend(position="bottomright",
            pal=pal5,
            values=get_blocks$geo_tag,
            title="DE Geoqualified Census Block Groups") 

  
```


The total popoulation, population at or below 200% and SNAP households and population are summarized below. Just under 10% of the total population in Delaware reside in census blocks geoqualified under the CEF program.  

```{r echo=FALSE, message=FALSE, warning=FALSE}

temp_table <- get_blocks %>% 
  st_drop_geometry() %>%
    mutate(Geoqualified = case_when(
    geo_tag == 1 ~ "Yes",
    TRUE ~ "No"
  )) %>%
  group_by(Geoqualified) %>%

  summarize(Population = sum(total_pop),
            `Population Under 200% FPL` = sum(total_under_200FPL),
            SNAP_HH = sum(snap_hh),
            SNAP_Pop = sum(snap_pop)) %>%
  adorn_totals("row")


datatable(temp_table, caption = "Delaware Geoqualified Population") %>%
    formatCurrency('Population',currency = "", interval = 3, digits = 0, mark = ",") %>%
    formatCurrency('Population Under 200% FPL',currency = "", interval = 3, digits = 0, mark = ",") %>%
    formatCurrency('SNAP_HH',currency = "", interval = 3, digits = 0, mark = ",") %>%
    formatCurrency('SNAP_Pop',currency = "", interval = 3, digits = 0, mark = ",")


```




## LMI Qualificaiton {.tabset}

There exists a number of options to verify customer income. Including:

    * (1) Proof of income of the account holder (e.g., pay stub or W2)
    * (2) proof of participation in a low income discount program including Medicaid, SSI, TANF, GA, WIC, LIHEAP, SNAP or food stamps
    * (3) proof that the Low-income Customer lives in a census block where the median household income is at or below 200% of the U.S. Federal Poverty Guidelines or 60% of the state median household income published by the United States Census Bureau, whichever is greater
    * (4) by living in a low-income master-metered building
    * (5) A written attestation by the Low-income Customer that their total household income is at or below 200% of the Federal Poverty Guidelines, or 60% of the state median household income published by the United States Census bureau, whichever is greater
    * NOTE For owners or operators of master-metered buildings, a written attestation that their tenants meet the income eligibility requirements for Low-income Customers
    
We use SNAP or food stamp recipient data as a proxy for low income discount programs. To keep consistency with the geoqualified tracts, we use block groups, hence Medicaid population is not available at this level. 

### SNAP

```{r echo=FALSE, message=FALSE, warning=FALSE}
pal5 <- colorNumeric(
  palette=c("Oranges"),
  domain=get_blocks$snap_pop
)


leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data=get_blocks,
              group="Block Groups",
             # stroke = TRUE,
              color = ~pal5(get_blocks$snap_pop),
              fillOpacity=0.75,
              popup=paste("Census Block Group: ", get_blocks$GEOID, "<br>",
                          "Percent under 200% FPL: ", get_blocks$pct_under_200FPL, "<br>",
                          "Number under 200% FPL: ", get_blocks$total_under_200FPL)) %>%
  addLegend(position="bottomright",
            pal=pal5,
            values=get_blocks$snap_pop,
            title="DE SNAP Population") 

  
```

### FPL

```{r echo=FALSE, message=FALSE, warning=FALSE}
pal5 <- colorNumeric(
  palette=c("Reds"),
  domain=get_blocks$pct_under_200FPL
)

pal6 <- colorNumeric(
  palette=c("Greens"),
  domain=get_blocks$total_under_200FPL
)


leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data=get_blocks,
              group="Percent",
             # stroke = TRUE,
              color = ~pal5(get_blocks$pct_under_200FPL),
              fillOpacity=0.65,
              popup=paste("Census Block Group: ", get_blocks$GEOID, "<br>",
                          "Percent under 200% FPL: ", get_blocks$pct_under_200FPL, "<br>",
                          "Number under 200% FPL: ", get_blocks$total_under_200FPL)) %>%
  addLegend(position="bottomright",
            pal=pal5,
            group = "Percent",
            values=get_blocks$pct_under_200FPL,
            title="DE Percent Under 200% FPL") %>%
  
    addPolygons(data=get_blocks,
              group="Total",
             # stroke = TRUE,
              color = ~pal6(get_blocks$total_under_200FPL),
              fillOpacity=0.65,
              popup=paste("Census Block Group: ", get_blocks$GEOID, "<br>",
                          "Percent under 200% FPL: ", get_blocks$pct_under_200FPL, "<br>",
                          "Number under 200% FPL: ", get_blocks$total_under_200FPL)) %>%
  addLegend(position="bottomright",
            pal=pal6,
            group= "Total",
            values=get_blocks$total_under_200FPL,
            title="DE Total Under 200% FPL")  %>%
  
    addLayersControl(
    overlayGroups=c( "Percent", "Total"),  # Update the order for consistency
    options = layersControlOptions(collapsed = FALSE)
  )

  
```



# New Jersey

We focus on the New Jersey Community Solar Energy Program (CSEP) market. 

```{r message=FALSE, warning=FALSE, include=FALSE}
temp_util <- st_read("utility_zones/NJ/Electric_Utilities_Territory_Map_of_New_Jersey.shp") %>%
  mutate(new_name = case_when(
    grepl("Municipal", NAME) ~ "Municipal",
    TRUE ~ NAME
  ))

temp_util <- st_make_valid(temp_util)

nj_geo_qual <- st_read("data/NJ/hud_80pct_80ami/Low_to_Moderate_Income_Population_by_Block_Group.shp") %>%
  mutate(total_pop = as.integer(Lowmoduniv),
         geo_tag = case_when(
           Lowmod_pct >= 0.8 ~ 1,
           TRUE ~ 0
         )
         )

  
```









```{r message=FALSE, warning=FALSE, include=FALSE}

get_tracts <- get_acs(
  geography="tract", 
  state="NJ",
  variables=c("Median Income" = "S1901_C01_012E"),
  year=2019, 
  geometry=TRUE) %>%
  mutate(MedInc = estimate) %>%
  select(geoid=GEOID, geometry)



```





```{r message=FALSE, warning=FALSE, include=FALSE}
chas_df <- load_chas() %>%
    mutate(State_Name = case_when(
    state == 17 ~ "Illinois",
    state == 25 ~ "Massachusetts",  
    state == 27 ~ "Minnesota",  
    state == 34 ~ "New Jersey",
    state == 35 ~ "New Mexico",  
    state == 36 ~ "New York",
    state == 06 ~ "California",
    TRUE ~ "Other"
  )) %>%
  filter(State_Name == "New Jersey")



add_geo <- merge(chas_df, get_tracts) 

add_geo <- st_as_sf(add_geo)


temp_util <- st_transform(temp_util, st_crs(add_geo)) %>%
  st_make_valid()
```




```{r echo=FALSE, message=FALSE, warning=FALSE}

pal5 <- colorFactor(
  palette="viridis",
  domain=temp_util$new_name
)

leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data=temp_util,
              group="Utility Zones",
              stroke=TRUE,
              color=~pal5(temp_util$new_name),
              dashArray="3",
              fillOpacity=0.5,
              popup=paste("Utility Zone: ", temp_util$new_name)) %>%
  addLegend(position="bottomright",
            pal=pal5,
            values=temp_util$new_name,
            title="Solstice NJ Utilities")
```
  


## Geoqualification

The New Jersey CSEP program allows for geoqualification. Residents must reside within a census block group in which 80 percent or more of the households earn less than 80 percent of the area median income, as determined by data from the U.S. Department of Housing and Urban Development. 

The below map shows the distribution of these households as defined by HUD: 

```{r echo=FALSE, message=FALSE, warning=FALSE}




pal5 <- colorFactor(
  palette=c("lightgrey", "darkgreen"),
  domain=nj_geo_qual$geo_tag
)


leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data=nj_geo_qual,
              group="Block Groups",
             # stroke = TRUE,
              color = ~pal5(nj_geo_qual$geo_tag),
              fillOpacity=0.75,
              popup=paste("Census Block Group: ", nj_geo_qual$GEOID, "<br>",
                          "Population: ", nj_geo_qual$total_pop)) %>%
  addLegend(position="bottomright",
            pal=pal5,
            values=nj_geo_qual$geo_tag,
            title="NJ Geoqualified Census Block Groups")  %>%
  
    addPolygons(data=temp_util,
              group="Utility Zones",
              stroke=TRUE,
              color="black",
              dashArray="3",
              fillOpacity=0,
              popup=paste("Utility: ", temp_util$new_name)) %>%
  
      addLayersControl(
    overlayGroups=c( "Block Groups", "Utility Zones"),  # Update the order for consistency
    options = layersControlOptions(collapsed = FALSE)
  )


```



```{r echo=FALSE, message=FALSE, warning=FALSE}

temp_table <- nj_geo_qual %>% 
  st_drop_geometry() %>%
  mutate(Geoqualified = case_when(
    geo_tag == 1 ~ "Yes",
    TRUE ~ "No"
  )) %>%
  group_by(Geoqualified) %>%

  summarize(Population = sum(total_pop)) %>%
  adorn_totals("row")


datatable(temp_table, caption = "New Jersey Geoqualified Population") %>%
    formatCurrency('Population',currency = "", interval = 3, digits = 0, mark = ",") 

```


```{r echo=FALSE, message=FALSE, warning=FALSE}





temp_util <- st_transform(temp_util, st_crs(nj_geo_qual))

temp_table <- nj_geo_qual %>% 
  st_point_on_surface() %>%
  st_make_valid() %>%
  st_join(temp_util %>% select(Utility = new_name)) %>%
  st_drop_geometry() %>%
  mutate(Geoqualified = case_when(
    geo_tag == 1 ~ "Yes",
    TRUE ~ "No"
  )) %>%
  group_by(Utility) %>%
  summarize(Geoqualified = sum(total_pop[geo_tag == 1]),
            NonGeoqualified = sum(total_pop[geo_tag == 0])) %>%
  #summarize(Population = sum(total_pop)) %>%
  adorn_totals("row")


datatable(temp_table, caption = "New Jersey Geoqualified Population by Utility") %>%
    formatCurrency('Geoqualified',currency = "", interval = 3, digits = 0, mark = ",") %>%
    formatCurrency('NonGeoqualified',currency = "", interval = 3, digits = 0, mark = ",") 


```











## LMI Qualificaiton

Self-attestation by the customer that their household income is less than 80 percent of the area median income, as determined by data from the U.S. Department of Housing and Urban Development, provided on a standard form to be approved by the Board and signed by the customer and recorded through an authorized administrator procured by the EDCs

- we'll get CHAS data to estimate number of HHs at or below 80% of AMI






```{r echo=FALSE, message=FALSE, warning=FALSE}



pal5 <- colorNumeric(
  palette=c("Oranges"),
  domain=add_geo$AMI_80
)


leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data=add_geo,
              group="LMI",
             # stroke = TRUE,
              color = ~pal5(add_geo$AMI_80),
              fillOpacity=0.75,
              popup=paste("Census Block Group: ", add_geo$GEOID, "<br>",
                          "Population < 80% AMI: ", add_geo$AMI_80)) %>%
  addLegend(position="bottomright",
            pal=pal5,
            values=add_geo$AMI_80,
            title="NJ LMI Population")  %>%
  
    addPolygons(data=temp_util,
              group="Utility Zones",
              stroke=TRUE,
              color="black",
              dashArray="3",
              fillOpacity=0,
              popup=paste("Utility: ", temp_util$new_name)) %>%
  
      addLayersControl(
    overlayGroups=c( "LMI", "Utility Zones"),  # Update the order for consistency
    options = layersControlOptions(collapsed = FALSE)
  )


```




```{r echo=FALSE, message=FALSE, warning=FALSE}

temp_table <- add_geo %>% 
  st_drop_geometry() %>%
  mutate(var = 1) %>%
  group_by(var) %>%
  summarize(LMI_Pop = sum(AMI_80)) %>%
  select(LMI_Pop) 


datatable(temp_table, caption = "New Jersey Geoqualified Population") %>%
    formatCurrency('LMI_Pop',currency = "", interval = 3, digits = 0, mark = ",") 

```


```{r echo=FALSE, message=FALSE, warning=FALSE}





temp_util <- st_transform(temp_util, st_crs(add_geo))

temp_table <- add_geo %>% 
  st_point_on_surface() %>%
  st_make_valid() %>%
  st_join(temp_util %>% select(Utility = new_name)) %>%
  st_drop_geometry() %>%
  group_by(Utility) %>%
  summarize(LMI_Pop = sum(AMI_80))%>%
  adorn_totals("row")


datatable(temp_table, caption = "New Jersey LMI Population by Utility") %>%
    formatCurrency('LMI_Pop',currency = "", interval = 3, digits = 0, mark = ",") 


```







# Massachusetts

## Geoqualification

## LMI Qualificaiton


# Minnesota

## Geoqualification

## LMI Qualificaiton





